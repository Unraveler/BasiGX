<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2015-present terrestris GmbH &amp; Co. KG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
<span id='BasiGX-view-container-OverpassSearch'>/**
</span> * Overpass Search
 *
 * Used to search in the glorious dataset of OSM
 *
 * Example of usage:
 *
 *     {
 *         xtype: &#39;basigx-search-overpass&#39;,
 *         clusterResults: true,
 *         viewboxlbrt: &#39;52.4677,6.9186,53.9642,11.2308&#39;
 *     }
 *
 * TODO This class has a lot in common with both #NominatimSearch and the
 *      generic #WfsSearch. We should factor out shared code.
 *
 * @class BasiGX.view.container.OverpassSearch
 */
Ext.define(&#39;BasiGX.view.container.OverpassSearch&#39;, {
    extend: &#39;Ext.container.Container&#39;,
    xtype: &#39;basigx-container-overpasssearch&#39;,

    requires: [
        &#39;GeoExt.data.store.Features&#39;,
        &#39;GeoExt.component.FeatureRenderer&#39;,

        &#39;BasiGX.util.Animate&#39;,
        &#39;BasiGX.util.Map&#39;,
        &#39;BasiGX.util.MsgBox&#39;
    ],

<span id='BasiGX-view-container-OverpassSearch-cfg-viewModel'>    viewModel: {
</span>        data: {
            searchTermTextFieldLabel: &#39;Suchbegriff&#39;,
            searchCriteriaGridTitle: &#39;Suchkategorien&#39;,
            searchCriteriaLabelTag: &#39;OSM-Tag&#39;,
            searchCriteriaCategoryTag: &#39;Kategorie&#39;,
            searchCriteriaOccurenceTag: &#39;Tag-Häufigkeit&#39;,
            searchResultGridTitle: &#39;Suchergebnisse&#39;,
            resetBtnText: &#39;Zurücksetzen&#39;,
            noMatchesFoundErrText: &#39;Keine passenden Einträge gefunden&#39;,
            documentation: &#39;&lt;h2&gt;Overpass-Suche&lt;/h2&gt;• Benutzen Sie die &#39; +
                &#39;Overpass Suche, um für ihren Suchbegriff passende Tags in &#39; +
                &#39;der OpenStreetMap Datenbank zu finden&#39;
        }
    },

    config: {
<span id='BasiGX-view-container-OverpassSearch-cfg-overpassUrl'>        /**
</span>         * The URL to the overpass service
         */
        overpassUrl: &#39;http://overpass-api.de/api/interpreter&#39;,

<span id='BasiGX-view-container-OverpassSearch-cfg-tagFinderUrl'>        /**
</span>         * The URL used to find tags for searchterms
         */
        tagFinderUrl: &#39;http://tagfinder.herokuapp.com/api/search&#39;,

<span id='BasiGX-view-container-OverpassSearch-cfg-format'>        /**
</span>         *
         */
        format: &#39;json&#39;,

<span id='BasiGX-view-container-OverpassSearch-cfg-limit'>        /**
</span>         * limit the search results count
         */
        limit: 300,

<span id='BasiGX-view-container-OverpassSearch-cfg-viewboxlbrt'>        /**
</span>         * The lat-lon viewbox to limit the searchquery to
         */
        viewboxlbrt: &#39;90,-180,-90,180&#39;,

<span id='BasiGX-view-container-OverpassSearch-cfg-minSearchTextChars'>        /**
</span>         * minimum chars to trigger the search
         */
        minSearchTextChars: 3,

<span id='BasiGX-view-container-OverpassSearch-cfg-typeDelay'>        /**
</span>         * delay before query gets triggered to avoid triggers while typing
         */
        typeDelay: 500,

<span id='BasiGX-view-container-OverpassSearch-cfg-groupHeaderTpl'>        /**
</span>         * the template to change the groups titles
         */
        groupHeaderTpl: &#39;{type}&#39;,

<span id='BasiGX-view-container-OverpassSearch-property-searchResultFeatureStyle'>        /**
</span>         * An `ol.style.Style` for search result features.
         *
         * @type {ol.style.Style}
         */
        searchResultFeatureStyle: new ol.style.Style({
            image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                    color: &#39;#8B0000&#39;
                }),
                stroke: new ol.style.Stroke({
                    color: &#39;#fff&#39;,
                    width: 2
                })
            }),
            fill: new ol.style.Fill({
                color: &#39;#8B0000&#39;
            }),
            stroke: new ol.style.Stroke({
                color: &#39;#8B0000&#39;,
                width: 4
            })
        }),

<span id='BasiGX-view-container-OverpassSearch-method-searchResultHighlightFeatureStyleFn'>        /**
</span>         * A function generating an `ol.style.Style` for highlighting features.
         *
         * @param {Number} radius The radius of the circle.
         * @param {String} text The text for the style.
         * @return {ol.style.Style} The generated style.
         */
        searchResultHighlightFeatureStyleFn: function(radius, text) {
            return new ol.style.Style({
                image: new ol.style.Circle({
                    radius: radius,
                    fill: new ol.style.Fill({
                        color: &#39;#EE0000&#39;
                    }),
                    stroke: new ol.style.Stroke({
                        color: &#39;gray&#39;,
                        width: 3
                    })
                }),
                text: text ? new ol.style.Text({
                    text: text.toString(),
                    fill: new ol.style.Fill({
                        color: &#39;#fff&#39;
                    })
                }) : undefined
            });
        },

<span id='BasiGX-view-container-OverpassSearch-property-searchResultSelectFeatureStyle'>        /**
</span>         * An `ol.style.Style` for selected search result features.
         *
         * @type {ol.style.Style}
         */
        searchResultSelectFeatureStyle: new ol.style.Style({
            image: new ol.style.Circle({
                radius: 8,
                fill: new ol.style.Fill({
                    color: &#39;#0099CC&#39;
                }),
                stroke: new ol.style.Stroke({
                    color: &#39;#fff&#39;,
                    width: 2
                })
            }),
            fill: new ol.style.Fill({
                color: &#39;#0099CC&#39;
            }),
            stroke: new ol.style.Stroke({
                color: &#39;#0099CC&#39;,
                width: 6
            })
        }),

<span id='BasiGX-view-container-OverpassSearch-method-clusterStyleFn'>        /**
</span>         * Returns an array of styles.
         *
         * TODO Are we accessing a private property here?
         *      `getSource().distance_` =&gt; this should be changed.
         *
         * @param {Number} amount The amount.
         * @param {Number} radius The radius.
         * @return {Array&lt;ol.style.Style&gt;} The generated styles.
         */
        clusterStyleFn: function(amount, radius) {
            // set maxradius
            var maxRadius = this.clusterLayer.getSource().distance_ / 2;
            if (radius &gt; maxRadius) {
                radius = maxRadius;
            }
            return [new ol.style.Style({
                image: new ol.style.Circle({
                    radius: radius,
                    stroke: new ol.style.Stroke({
                        color: &#39;#fff&#39;
                    }),
                    fill: new ol.style.Fill({
                        color: &#39;#3399CC&#39;
                    })
                }),
                text: new ol.style.Text({
                    text: amount.toString(),
                    fill: new ol.style.Fill({
                        color: &#39;#fff&#39;
                    })
                })
            })];
        },

<span id='BasiGX-view-container-OverpassSearch-property-highLightFeatureOnHoverInGrid'>        /**
</span>         * Whether we want to highlight the associated feature in the map when
         * we hover over the row for the feature in the grid.
         *
         * @type {Boolean}
         */
        highLightFeatureOnHoverInGrid: true
    },

<span id='BasiGX-view-container-OverpassSearch-property-layout'>    /**
</span>     *
     */
    layout: &#39;fit&#39;,

<span id='BasiGX-view-container-OverpassSearch-property-typeDelayTask'>    /**
</span>     *
     */
    typeDelayTask: null,

<span id='BasiGX-view-container-OverpassSearch-property-searchTerm'>    /**
</span>     *
     */
    searchTerm: null,

<span id='BasiGX-view-container-OverpassSearch-property-searchResultVectorLayer'>    /**
</span>     *
     */
    searchResultVectorLayer: null,

<span id='BasiGX-view-container-OverpassSearch-property-clusterLayer'>    /**
</span>     *
     */
    clusterLayer: null,

<span id='BasiGX-view-container-OverpassSearch-property-clusterResults'>    /**
</span>     *
     */
    clusterResults: false,

<span id='BasiGX-view-container-OverpassSearch-property-styleCache'>    /**
</span>     *
     */
    styleCache: [],

<span id='BasiGX-view-container-OverpassSearch-property-map'>    /**
</span>     *
     */
    map: null,

<span id='BasiGX-view-container-OverpassSearch-method-initComponent'>    /**
</span>     *
     */
    initComponent: function() {
        var me = this;

        // set map
        me.map = BasiGX.util.Map.getMapComponent().getMap();

        if (!me.searchResultVectorLayer) {
            me.searchResultVectorLayer = new ol.layer.Vector({
                name: &#39;overpasssearchresult&#39;,
                source: new ol.source.Vector({
                    features: new ol.Collection()
                }),
                style: me.getSearchResultFeatureStyle(),
                visible: !me.clusterResults
            });
            me.map.addLayer(me.searchResultVectorLayer);
        }

        if (me.clusterResults &amp;&amp; !me.clusterLayer) {
            var clusterSource = new ol.source.Cluster({
                distance: 40,
                source: me.searchResultVectorLayer.getSource()
            });

            me.clusterLayer = new ol.layer.Vector({
                name: &#39;overpassclusterlayer&#39;,
                source: clusterSource,
                style: function(feature) {
                    var amount = feature.get(&#39;features&#39;).length;
                    var style = me.styleCache[amount];
                    if (!style) {
                        style = me.clusterStyleFn(amount, amount + 10);
                        me.styleCache[amount] = style;
                    }
                    return style;
                }
            });
            me.map.addLayer(me.clusterLayer);

            // correct the vectorlayerstyle for the grid symbolizer
            me.searchResultVectorLayer.setStyle(me.clusterStyleFn(&#39;&#39;, 8));
        }

        var tagFinderResultStore = Ext.create(&#39;Ext.data.Store&#39;, {
            sorters: [{
                property: &#39;countAll&#39;,
                direction: &#39;DESC&#39;
            }],
            fields: [
                &#39;prefLabel&#39;,
                {
                    name: &#39;termRelated&#39;,
                    type: &#39;string&#39;,
                    convert: function(val) {
                        return val.de[0] ? val.de[0] : &#39;-&#39;;
                    }
                },
                &#39;countAll&#39;
            ]
        });

        var searchResultStore = Ext.create(&#39;GeoExt.data.store.Features&#39;, {
            map: me.map,
            layer: me.searchResultVectorLayer,
            groupField: &#39;type&#39;
        });

        me.items = [
            {
                xtype: &#39;textfield&#39;,
                name: &#39;overpassSearchTerm&#39;,
                bind: {
                    fieldLabel: &#39;{searchTermTextFieldLabel}&#39;
                },
                enableKeyEvents: true,
                listeners: {
                    change: me.handleKeyDown
                }
            },
            {
                xtype: &#39;grid&#39;,
                name: &#39;tagfinderresultgrid&#39;,
                hidden: true,
                bind: {
                    title: &#39;{searchCriteriaGridTitle}&#39;
                },
                store: tagFinderResultStore,
                columns: [
                    {
                        dataIndex: &#39;prefLabel&#39;,
                        bind: {
                            text: &#39;{searchCriteriaLabelTag}&#39;
                        },
                        flex: 3,
                        renderer: function(value) {
                            return &#39;&lt;span data-qtip=&quot;&#39; + value + &#39;&quot;&gt;&#39; +
                                value + &#39;&lt;/span&gt;&#39;;
                        }
                    },
                    {
                        dataIndex: &#39;termRelated&#39;,
                        bind: {
                            text: &#39;{searchCriteriaCategoryTag}&#39;
                        },
                        flex: 3,
                        renderer: function(value) {
                            return &#39;&lt;span data-qtip=&quot;&#39; + value + &#39;&quot;&gt;&#39; +
                                value + &#39;&lt;/span&gt;&#39;;
                        }
                    },
                    {
                        dataIndex: &#39;countAll&#39;,
                        bind: {
                            text: &#39;{searchCriteriaOccurenceTag}&#39;
                        },
                        flex: 2
                    }
                ],
                width: 200,
                height: 300
            },
            {
                xtype: &#39;grid&#39;,
                name: &#39;overpasssearchresultgrid&#39;,
                hidden: true,
                hideHeaders: true,
                bind: {
                    title: &#39;{searchResultGridTitle}&#39;
                },
                store: searchResultStore,
                columns: [
                    {
                        xtype: &#39;widgetcolumn&#39;,
                        flex: 1,
                        widget: {
                            xtype: &#39;gx_renderer&#39;
                        },
                        onWidgetAttach: function(column, gxRenderer, record) {
                            // update the symbolizer with the related feature
                            var feature = record.olObject;
                            gxRenderer.update({
                                feature: feature,
                                symbolizers: GeoExt.component.FeatureRenderer
                                    .determineStyle(record)
                            });
                        }
                    },
                    {
                        dataIndex: &#39;displayfield&#39;,
                        flex: 7,
                        renderer: function(value) {
                            return &#39;&lt;span data-qtip=&quot;&#39; + value + &#39;&quot;&gt;&#39; +
                                value + &#39;&lt;/span&gt;&#39;;
                        }
                    }
                ],
                features: [{
                    ftype: &#39;grouping&#39;,
                    groupHeaderTpl: me.getGroupHeaderTpl()
                }],
                width: 200,
                height: 300
            }, {
                xtype: &#39;button&#39;,
                bind: {
                    text: &#39;{resetBtnText}&#39;
                },
                margin: &#39;10 0 0 0&#39;,
                handler: me.resetSearchGridAndText,
                scope: me
            }
        ];
        me.callParent(arguments);

        var grid = me.down(&#39;grid[name=overpasssearchresultgrid]&#39;);
        var tagFinderGrid = me.down(&#39;grid[name=tagfinderresultgrid]&#39;);

        me.on(&#39;tagfinderResponse&#39;, function(res) {
            tagFinderGrid.getStore().loadData(res);
            tagFinderGrid.show();
        });
        me.on(&#39;overpassResponse&#39;, me.showSearchResults, me);

        me.on(&#39;show&#39;, me.down(&#39;textfield&#39;).focus);

        if (me.getHighLightFeatureOnHoverInGrid()) {
            grid.on(&#39;itemmouseenter&#39;, me.highlightFeature, me);
            grid.on(&#39;itemmouseleave&#39;, me.unhighlightFeature, me);
        }
        grid.on(&#39;itemclick&#39;, me.highlightSelectedFeature, me);
        tagFinderGrid.on(&#39;itemclick&#39;, me.triggerSearch, me);
    },

<span id='BasiGX-view-container-OverpassSearch-method-handleKeyDown'>    /**
</span>     * Bound to the `change`-event of the textfield.
     *
     * @param {Ext.form.field.Text} textfield The textfield in which one enters
     *     the query.
     */
    handleKeyDown: function(textfield) {
        var overpassContainer = textfield.up(&#39;basigx-container-overpasssearch&#39;);
        var val = textfield.getValue();

        if (val.length &lt; overpassContainer.getMinSearchTextChars()) {
            return;
        }

        // set the searchterm on component
        overpassContainer.searchTerm = val;

        // reset grid from old values
        overpassContainer.resetGrids();

        // prepare the describeFeatureType for all given layers
        if (overpassContainer.typeDelayTask) {
            overpassContainer.typeDelayTask.cancel();
        }
        overpassContainer.typeDelayTask = new Ext.util.DelayedTask(function() {
            overpassContainer.findTagForSearchTerm();
        });
        overpassContainer.typeDelayTask.delay(overpassContainer.getTypeDelay());

    },

<span id='BasiGX-view-container-OverpassSearch-method-resetSearchGridAndText'>    /**
</span>     *
     */
    resetSearchGridAndText: function() {
        var me = this;
        me.down(&#39;textfield[name=overpassSearchTerm]&#39;).setValue(&#39;&#39;);
        me.resetGrids();
    },

<span id='BasiGX-view-container-OverpassSearch-method-resetGrids'>    /**
</span>     *
     */
    resetGrids: function() {
        var me = this;
        var overpassGrid = me.down(&#39;grid[name=overpasssearchresultgrid]&#39;);
        var tagFinderGrid = me.down(&#39;grid[name=tagfinderresultgrid]&#39;);
        me.searchResultVectorLayer.getSource().clear(true);
        overpassGrid.hide();
        overpassGrid.getStore().removeAll();
        tagFinderGrid.hide();
        tagFinderGrid.getStore().removeAll();
    },

<span id='BasiGX-view-container-OverpassSearch-method-findTagForSearchTerm'>    /**
</span>     * find osm tags for the searchterm
     */
    findTagForSearchTerm: function() {
        var me = this;
        var results;

        var requestParams = {
            query: me.searchTerm,
            format: &#39;json&#39;,
            lang: &#39;de&#39;
        };

        var url = me.getTagFinderUrl() + &#39;?&#39;;
        Ext.iterate(requestParams, function(k, v) {
            url += k + &#39;=&#39; + encodeURIComponent(v) + &#39;&amp;&#39;;
        });

        me.setLoading(true);

        Ext.Ajax.request({
            url: url,
            success: function(response) {
                me.setLoading(false);
                if (Ext.isString(response.responseText)) {
                    results = Ext.decode(response.responseText);
                } else if (Ext.isObject(response.responseText)) {
                    results = response.responseText;
                } else {
                    Ext.log.error(&#39;Error! Could not parse &#39; +
                        &#39;tagfinder response!&#39;);
                }
                if (results.length &gt; 0) {
                    var tagArray = [];
                    Ext.each(results, function(res) {
                        if (res.isTag) {
                            tagArray.push(res);
                        }
                    });
                    me.fireEvent(&#39;tagfinderResponse&#39;, tagArray);
                } else {
                    BasiGX.util.MsgBox.info(me.getViewModel().get(
                        &#39;noMatchesFoundErrText&#39;));
                }

            },
            failure: function(response) {
                me.setLoading(false);
                Ext.log.error(&#39;Error on tagfinder request:&#39;,
                    response);
            }
        });
    },

<span id='BasiGX-view-container-OverpassSearch-method-triggerSearch'>    /**
</span>     * Starts the search based on the clicked tag.
     *
     * @param {Ext.grid.Panel} grid The tag finder grid.
     * @param {Ext.data.Model} rec The clicked tag-record.
     */
    triggerSearch: function(grid, rec) {
        var me = this;
        var tagFinderGrid = me.down(&#39;grid[name=tagfinderresultgrid]&#39;);

        if (tagFinderGrid.isVisible()) {
            tagFinderGrid.hide();
        }

        var requestParams = {
            data: &#39;[out:&#39; + me.getFormat() + &#39;];&#39;
        };

        requestParams.data += &#39;node[&#39; + rec.data.prefLabel + &#39;]&#39;;
        requestParams.data += &#39;(&#39; + me.getViewboxlbrt() + &#39;);&#39;;
        requestParams.data += &#39;out &#39; + me.getLimit() + &#39; qt;&#39;;

        var url = me.getOverpassUrl() + &#39;?&#39;;

        me.setLoading(true);

        Ext.Ajax.request({
            url: url,
            params: {data: requestParams.data},
            success: function(response) {
                me.setLoading(false);
                var results;
                if (Ext.isString(response.responseText)) {
                    results = Ext.decode(response.responseText);
                } else if (Ext.isObject(response.responseText)) {
                    results = response.responseText;
                } else {
                    Ext.log.error(&#39;Error! Could not parse &#39; +
                        &#39;overpass response!&#39;);
                }
                me.fireEvent(&#39;overpassResponse&#39;, results);
            },
            failure: function(response) {
                me.setLoading(false);
                Ext.log.error(&#39;Error on overpass request:&#39;,
                    response);
            }
        });
    },

<span id='BasiGX-view-container-OverpassSearch-method-showSearchResults'>    /**
</span>     * Show the search results in the grid.
     *
     * @param {Object} response The XHR response.
     */
    showSearchResults: function(response) {
        var me = this;
        var grid = me.down(&#39;grid[name=overpasssearchresultgrid]&#39;);
        var features = response.elements;

        if (features.length &gt; 0) {
            grid.show();
        }

        Ext.each(features, function(feature) {

            var olFeat = new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.transform(
                    [parseFloat(feature.lon), parseFloat(feature.lat)],
                    &#39;EPSG:4326&#39;, &#39;EPSG:3857&#39;
                )),
                properties: feature
            });
            olFeat.set(&#39;displayfield&#39;,
                feature.tags.name || &#39;Kein Name gefunden&#39; // TODO i18n
            );

            me.searchResultVectorLayer.getSource().addFeature(olFeat);
        });

        me.searchResultVectorLayer.setStyle(me.getSearchResultFeatureStyle());

        var featureExtent = me.searchResultVectorLayer.getSource().getExtent();
        if (!Ext.Array.contains(featureExtent, Infinity)) {
            me.zoomToExtent(featureExtent);
        }
    },

<span id='BasiGX-view-container-OverpassSearch-method-zoomToExtent'>    /**
</span>     * Works with extent or geom.
     *
     * @param {ol.Extent|ol.geom.SimpleGeometry} extent The extent or geometry
     *     to zoom to.
     */
    zoomToExtent: function(extent) {
        var me = this;
        var olView = me.map.getView();

        // This if is need for backwards compatibility to ol
        if (ol.animation) {
            var pan = ol.animation.pan({
                source: olView.getCenter()
            });
            var zoom = ol.animation.zoom({
                resolution: olView.getResolution()
            });
            me.map.beforeRender(pan, zoom);
            olView.fit(extent, me.map.getSize());
        } else {
            olView.fit(extent, {
                duration: 500
            });
        }
    },

<span id='BasiGX-view-container-OverpassSearch-method-updateRenderer'>    /**
</span>     * Update the symbolizer in the grid.
     *
     * @param {HTMLElement} item The HTML-element where the renderer lives in.
     * @param {ol.style.Style} style The new style for the renderer.
     */
    updateRenderer: function(item, style) {
        var renderer = Ext.getCmp(
            Ext.query(&#39;div[id^=gx_renderer&#39;, true, item)[0].id);
        var src = renderer.map.getLayers().getArray()[0].getSource();
        src.getFeatures()[0].setStyle(style);
    },

<span id='BasiGX-view-container-OverpassSearch-method-highlightFeature'>    /**
</span>     * Highlights the feature.
     *
     * Bound to the `itemmouseenter`-event on the grid.
     *
     * @param {Ext.view.View} tableView The tableView / grid.
     * @param {Ext.data.Model} record The record that belongs to the item.
     * @param {HTMLElement} item The item&#39;s element.
     */
    highlightFeature: function(tableView, record, item) {
        if (this.enterEventRec === record) {
            return;
        }
        var feature;
        var radius;
        var text;

        this.enterEventRec = record;
        ol.Observable.unByKey(this.flashListenerKey);

        if (this.clusterResults) {
            feature = this.getClusterFeatureFromFeature(record.olObject);
            var featureStyle = this.clusterLayer.getStyle()(
                feature, this.map.getView().getResolution())[0];
            radius = featureStyle.getImage().getRadius();
            text = featureStyle.getText().getText();
        } else {
            feature = record.olObject;
            radius = 5; // default value
        }

        if (tableView.getSelection()[0] !== record) {
            feature.setStyle(
                this.getSearchResultHighlightFeatureStyleFn()(radius, text)
            );
            this.updateRenderer(item,
                this.getSearchResultHighlightFeatureStyleFn()(8, text)
            );
        }
        if (feature) {
            this.flashListenerKey = BasiGX.util.Animate.flashFeature(
                feature, 1000, radius, this.searchResultVectorLayer);
        }
    },

<span id='BasiGX-view-container-OverpassSearch-method-unhighlightFeature'>    /**
</span>     * Unhighlights a previously highlighted feature.
     *
     * Bound to the `itemmouseleave`-event on the grid.
     *
     * @param {Ext.view.View} tableView The tableView / grid.
     * @param {Ext.data.Model} record The record that belongs to the item.
     * @param {HTMLElement} item The item&#39;s element.
     */
    unhighlightFeature: function(tableView, record, item) {
        if (this.leaveEventRec === record) {
            return;
        }
        this.leaveEventRec = record;
        if (tableView.getSelection()[0] !== record) {
            record.olObject.setStyle(this.getSearchResultFeatureStyle());
            if (this.clusterResults) {
                this.updateRenderer(item, this.clusterStyleFn(&#39;&#39;, 8));
            } else {
                this.updateRenderer(item, this.getSearchResultFeatureStyle());
            }
        }
    },

<span id='BasiGX-view-container-OverpassSearch-method-highlightSelectedFeature'>    /**
</span>     * Highlights a selected feature.
     *
     * Bound to the `itemclick`-event on the grid.
     *
     * @param {Ext.view.View} tableView The tableView / grid.
     * @param {Ext.data.Model} record The record that belongs to the item.
     * @param {HTMLElement} item The item&#39;s element.
     */
    highlightSelectedFeature: function(tableView, record, item) {
        record.olObject.setStyle(this.getSearchResultSelectFeatureStyle());
        this.updateRenderer(item, this.getSearchResultSelectFeatureStyle());
        this.zoomToExtent(record.olObject.getGeometry());
    },

<span id='BasiGX-view-container-OverpassSearch-method-getClusterFeatureFromFeature'>    /**
</span>     * Returns the cluster feature from the given `ol.Feature`.
     *
     * @param {ol.Feature} feature The feature to get the cluster feature from.
     * @return {ol.Feature} The cluster feature.
     */
    getClusterFeatureFromFeature: function(feature) {
        var me = this;
        var clusterFeature;
        var clusterFeatures = me.clusterLayer.getSource().getFeatures();
        Ext.each(clusterFeatures, function(feat) {
            if (!Ext.isEmpty(feat.get(&#39;features&#39;))) {
                Ext.each(feat.get(&#39;features&#39;), function(f) {
                    if (f.getProperties().properties.id &amp;&amp;
                        feature.getProperties().properties.id &amp;&amp;
                        f.getProperties().properties.id ===
                        feature.getProperties().properties.id) {
                        clusterFeature = feat;
                        return false;
                    }
                });
            }
            if (!Ext.isEmpty(clusterFeature)) {
                return false;
            }
        });
        return clusterFeature ? clusterFeature : feature;
    }
});
</pre>
</body>
</html>
