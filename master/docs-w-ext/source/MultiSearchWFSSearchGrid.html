<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2016-present terrestris GmbH &amp; Co. KG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid'>/**
</span> *  A grid showing results of the multisearch WFS search response values.
 *  inspired by BasiGX.view.container.WfsSearch
 *  This class is used by BasiGX.view.form.field.MultiSearchCombo
 *
 * @class BasiGX.view.grid.MultiSearchWFSSearchGrid
 *
 * @extends Ext.grid.Panel
 *
 * @requires GeoExt.component.FeatureRenderer
 * @requires GeoExt.data.store.Features
 * @requires BasiGX.util.Map
 * @requires BasiGX.util.Layer
 * @requires BasiGX.util.Animate
 *
 */
Ext.define(&#39;BasiGX.view.grid.MultiSearchWFSSearchGrid&#39;, {
    extend: &#39;Ext.grid.Panel&#39;,
    xtype: &#39;basigx-grid-multisearchwfssearchgrid&#39;,

    requires: [
        &#39;GeoExt.component.FeatureRenderer&#39;,
        &#39;GeoExt.data.store.Features&#39;,
        &#39;BasiGX.util.Map&#39;,
        &#39;BasiGX.util.Layer&#39;,
        &#39;BasiGX.util.Animate&#39;,
        &#39;BasiGX.util.StringTemplate&#39;
    ],

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-viewModel'>    viewModel: {
</span>        data: {
            title: &#39;Objektsuche&#39;
        }
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-bind'>    bind: {
</span>        title: &#39;{title}&#39;
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-store'>    store: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-cls'>    cls: &#39;search-result-grid&#39;,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-searchResultVectorLayer'>    searchResultVectorLayer: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-collapsible'>    collapsible: true,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-titleCollapse'>    titleCollapse: true,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-collapseDirection'>    collapseDirection: &#39;top&#39;,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-headerPosition'>    headerPosition: &#39;left&#39;,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-hideHeaders'>    hideHeaders: true,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-maxHeight'>    maxHeight: 180,
</span>
    config: {

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-combo'>        combo: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-minSearchTextChars'>        minSearchTextChars: 3,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-typeDelay'>        typeDelay: 300,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-allowedFeatureTypeDataTypes'>        allowedFeatureTypeDataTypes: [
</span>            &#39;xsd:string&#39;
        ],

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-searchTerm'>        searchTerm: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-map'>        map: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-layer'>        layer: null,
</span>
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-useLayerName'>        /**
</span>         * If set to true, the layer name will be used for grouping in the
         * grid.
         */
        useLayerName: false,

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-templateConfig'>        /**
</span>         * Object containing two keys - suffix and prefix - to match begin and
         * end of any placeholder in the display template of search results.
         * If not set, fallback values `TEMPLATE_PLACEHOLDER_PREFIX` and
         *`TEMPLATE_PLACEHOLDER_SUFFIX` from `BasiGX.util.StringTemplate` util
         * will be assumed by templating.
         */
        templateConfig: {},

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-zoomToSearchResults'>        /**
</span>         * Whether the map should zoom to clicked search result.
         * If set to false, the map will be only centered on chosen object,
         * otherwise the map view will be adapted to fit the selected feature.
         */
        zoomToSearchResults: false,

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-zoomToScale'>        /**
</span>         * Custom map scale value, which will be used by zoom to clicked search
         * result. Applies only if #zoomToSearchResults set to true and desired
         * geometry type is configured.
         */
        zoomToScale: {
            point: 1000,
            multipoint: 1000
        },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-searchResultFeatureStyle'>        searchResultFeatureStyle: new ol.style.Style({
</span>            image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                    color: &#39;#4990D1&#39;
                }),
                stroke: new ol.style.Stroke({
                    color: &#39;#fff&#39;,
                    width: 2
                })
            }),
            stroke: new ol.style.Stroke({
                color: &#39;#4990D1&#39;,
                width: 4
            })
        }),

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-searchResultHighlightFeatureStyle'>        searchResultHighlightFeatureStyle: new ol.style.Style({
</span>            image: new ol.style.Circle({
                radius: 8,
                fill: new ol.style.Fill({
                    color: &#39;#EE0000&#39;
                }),
                stroke: new ol.style.Stroke({
                    color: &#39;#fff&#39;,
                    width: 2
                })
            }),
            stroke: new ol.style.Stroke({
                color: &#39;#EE0000&#39;,
                width: 6
            })
        }),

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-searchResultSelectFeatureStyle'>        /**
</span>         *
         */
        searchResultSelectFeatureStyle: new ol.style.Style({
            image: new ol.style.Circle({
                radius: 10,
                fill: new ol.style.Fill({
                    color: &#39;#EE0000&#39;
                }),
                stroke: new ol.style.Stroke({
                    color: &#39;#fff&#39;,
                    width: 2
                })
            }),
            stroke: new ol.style.Stroke({
                color: &#39;#EE0000&#39;,
                width: 8
            })
        }),

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-cfg-flashStyle'>        flashStyle: function() {
</span>            return [new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 5
                })
            })];
        }

    },


<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-features'>    /**
</span>     *
     */
    features: [{
        ftype: &#39;grouping&#39;,
        groupHeaderTpl: &#39;{name} ({children.length})&#39;
    }],

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-columns'>    /**
</span>     *
     */
    columns: [
<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-property-'>        /**
</span>         * @todo gx_renderer doesn&#39;t render all features every time
         */
        //    {
        //        xtype: &#39;widgetcolumn&#39;,
        //        flex: 1,
        //        widget: {
        //            xtype: &#39;gx_renderer&#39;
        //        },
        //        onWidgetAttach: function(column, gxRenderer, record) {
        //            // update the symbolizer with the related feature
        //            var feature = record.getFeature();
        //            gxRenderer.update({
        //                feature: feature,
        //                symbolizers: this.up(&#39;grid&#39;)
        // .getSearchResultFeatureStyle()
        //            });
        //        }
        //    },
        {
            text: &#39;Feature&#39;,
            dataIndex: &#39;displayfield&#39;,
            flex: 5,
            renderer: function(value) {
                return &#39;&lt;span data-qtip=&quot;&#39; + value + &#39;&quot;&gt;&#39; +
                    value + &#39;&lt;/span&gt;&#39;;
            }
        }
    ],

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-initComponent'>    /**
</span>     *
     */
    initComponent: function() {
        var me = this;

        me.callParent(arguments);

        me.map = BasiGX.util.Map.getMapComponent().getMap();

        if (!me.searchResultVectorLayer) {
            me.searchResultVectorLayer = new ol.layer.Vector({
                name: &#39;Object Search Results&#39;,
                source: new ol.source.Vector({
                    features: new ol.Collection()
                }),
                style: me.getSearchResultFeatureStyle(),
                hoverable: false
            });

            var displayInLayerSwitcherKey =
                BasiGX.util.Layer.KEY_DISPLAY_IN_LAYERSWITCHER;
            me.searchResultVectorLayer.set(displayInLayerSwitcherKey, false);
            me.map.addLayer(me.searchResultVectorLayer);
        }

        var searchResultStore = Ext.create(&#39;GeoExt.data.store.Features&#39;, {
            map: me.map,
            layer: me.searchResultVectorLayer,
            groupField: &#39;featuretype&#39;
        });

        me.setStore(searchResultStore);

        me.on(&#39;describeFeatureTypeResponse&#39;, me.getFeatures);
        me.on(&#39;getFeatureResponse&#39;, me.showSearchResults);

        me.on(&#39;boxready&#39;, me.onBoxReady, me);

        // add listeners for interaction between grid and found features
        // while grid is visible
        me.on(&#39;afterrender&#39;, me.registerListeners, me);
        me.on(&#39;show&#39;, me.registerListeners, me);

        // unregister the same listeners on grid hide
        me.on(&#39;hide&#39;, me.unregisterListeners, me);
        me.on(&#39;destroy&#39;, me.unregisterListeners, me);

    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-registerListeners'>    /**
</span>     * Called once the grid is shown. Registers all related listeners for
     * interaction between grid and features on the map.
     */
    registerListeners: function() {
        var me = this;
        me.on(&#39;itemmouseenter&#39;, me.highlightFeature, me);
        me.on(&#39;itemmouseleave&#39;, me.unhighlightFeature, me);
        me.on(&#39;itemclick&#39;, me.highlightSelectedFeature, me);
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-unregisterListeners'>    /**
</span>     * Called once the grid turns hidden. Deactivates all related listeners for
     * interaction between grid and features on the map.
     */
    unregisterListeners: function() {
        var me = this;
        me.un(&#39;itemmouseenter&#39;, me.highlightFeature, me);
        me.un(&#39;itemmouseleave&#39;, me.unhighlightFeature, me);
        me.un(&#39;itemclick&#39;, me.highlightSelectedFeature, me);
    },


<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-describeFeatureTypes'>    /**
</span>     * Called by BasiGX.view.form.field.MultiSearchCombo.doObjectSearch()
     * This method starts the search by requesting the WFS-DescribyFeatureType
     * for all wanted layers.
     *
     * @param {string} searchterm The search term
     * @param {Ext.form.field.Combo} combo The calling combobox to set it on the
     *     WFSGrid
     */
    describeFeatureTypes: function(searchterm, combo) {
        var me = this;
        var featureTypes;

        me.searchResultVectorLayer.getSource().clear();

        me.setSearchTerm(searchterm);

        me.setCombo(combo);

        var searchLayers = combo.getConfiguredSearchLayers();
        var workspaces = {};

        Ext.each(searchLayers, function(l) {
            if (l.getSource().getParams) {
                var fqLayerName = l.getSource().getParams().LAYERS;
                var split = fqLayerName.split(&#39;:&#39;);
                if (split.length !== 2) {
                    split = [&#39;&#39;, split[1]];
                }
                if (!(split[0] in workspaces)) {
                    workspaces[split[0]] = [];
                }
                workspaces[split[0]].push(fqLayerName);
            }
        });

        var params = Ext.Array.map(Object.keys(workspaces),
            function(workspace) {
                return {
                    REQUEST: &#39;DescribeFeatureType&#39;,
                    SERVICE: &#39;WFS&#39;,
                    VERSION: &#39;1.1.0&#39;,
                    OUTPUTFORMAT: &#39;application/json&#39;,
                    TYPENAME: workspaces[workspace].toString()
                };
            });

        me.setLoading(true);

        Ext.Promise.all(Ext.Array.map(params, function(param) {
            return Ext.Ajax.request({
                url: combo.getWfsServerUrl(),
                params: param,
                method: &#39;GET&#39;
            });
        })).then(function(responses) {
            me.setLoading(false);
            var dirtyFeatureTypes = Ext.Array.map(responses,
                function(response) {
                    try {
                        var resFeatureTypes;
                        if (Ext.isString(response.responseText)) {
                            resFeatureTypes = Ext.decode(response.responseText);
                        } else if (Ext.isObject(response.responseText)) {
                            resFeatureTypes = response.responseText;
                        } else {
                            Ext.log.error(&#39;Error! Could not parse &#39; +
                                &#39;describe featuretype response!&#39;);
                        }
                        if (resFeatureTypes) {
                            return resFeatureTypes;
                        }
                    } catch (error) {
                        Ext.log.error(&#39;Error on describe featuretype request:&#39;,
                            error);
                    }
                });
            featureTypes = Ext.Array.clean(dirtyFeatureTypes);
            me.fireEvent(&#39;describeFeatureTypeResponse&#39;,
                featureTypes);

        }).catch(function(response) {
            me.setLoading(false);
            Ext.log.error(&#39;Error on describe featuretype request:&#39;,
                response);
        });
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-getFeatures'>    /**
</span>     * Called by describeFeatureTypeResponse event fired by successfull
     * describeFeatureTypes() response.
     *
     * This method requests the actual features fitting to the search term.
     *
     * @param {Array} responses The array of ajax responses
     *                          containing DescribeFeatureType.
     */
    getFeatures: function(responses) {
        var me = this;

        me.setLoading(true);
        Ext.Promise.all(Ext.Array.map(responses, function(resp) {
            var featureTypes = resp.featureTypes;
            var ns = resp.targetPrefix;
            var cleanedFeatureType = me.cleanUpFeatureDataTypes(featureTypes);
            var url = me.getCombo().getWfsServerUrl();
            var xml = me.setupXmlPostBody(cleanedFeatureType, ns);
            var features;
            return Ext.Ajax.request({
                url: url,
                method: &#39;POST&#39;,
                headers: BasiGX.util.CSRF.getHeader(),
                xmlData: xml,
                success: function(response) {
                    me.setLoading(false);
                    if (Ext.isString(response.responseText)) {
                        features = Ext.decode(response.responseText).features;
                    } else if (Ext.isObject(response.responseText)) {
                        features = response.responseText.features;
                    } else {
                        Ext.log.error(&#39;Error! Could not parse &#39; +
                            &#39;GetFeature response!&#39;);
                    }
                    me.fireEvent(&#39;getFeatureResponse&#39;, features);
                },
                failure: function(response) {
                    me.setLoading(false);
                    Ext.log.error(&#39;Error on GetFeature request:&#39;,
                        response);
                }
            });
        })).then(function(resps) {
            me.setLoading(false);
            var features = [];
            Ext.Array.each(resps, function(resp) {
                var feats;
                if (Ext.isString(resp.responseText)) {
                    feats = Ext.decode(resp.responseText).features;
                } else if (Ext.isObject(resp.responseText)) {
                    feats = resp.responseText.features;
                } else {
                    Ext.log.error(&#39;Error! Could not parse &#39; +
                        &#39;GetFeature response!&#39;);
                }
                features = Ext.Array.merge(features, feats);
            });
            me.fireEvent(&#39;getFeatureResponse&#39;, features);
        }).catch(function(response){
            me.setLoading(false);
            Ext.log.error(&#39;Error on GetFeature request:&#39;,
                response);
        });
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-cleanUpFeatureDataTypes'>    /**
</span>     * This method removes unwanted dataTypes from the passed ones.
     *
     * Called by getFeatures() for less vulnerability
     *
     * @param {Array&lt;Object&gt;} featureTypes The featuretypes.
     * @return {Array&lt;Object&gt;} The wanted typenames.
     */
    cleanUpFeatureDataTypes: function(featureTypes) {
        var me = this;
        var cleanedFeatureType = [];
        Ext.each(featureTypes, function(ft, index) {
            cleanedFeatureType.push({
                typeName: ft.typeName,
                properties: []
            });

            Ext.each(ft.properties, function(prop) {
                if (Ext.Array.contains(
                    me.getAllowedFeatureTypeDataTypes(), prop.type) &amp;&amp;
                    prop.name.indexOf(&#39; &#39;) &lt; 0) {
                    cleanedFeatureType[index].properties.push(prop);
                }
            });
        });
        return cleanedFeatureType;
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-setupXmlPostBody'>    /**
</span>     * Sets up a XML as string for a &#39;wfs:GetFeature&#39;-operation.
     *
     * Called by #getFeatures to build the POST Body. It decides if the search
     * should be done in the visible extent only.
     *
     * @param {Array&lt;Object&gt;} featureTypes The featuretypes.
     * @param {String} namespace Featuretype namespace from DescribeFeatureType
     *     response. Will only be used if `wfsPrefix` config of parent combo is
     *     not set.
     * @return {String} The XML.
     */
    setupXmlPostBody: function(featureTypes, namespace) {
        var me = this;
        var combo = me.getCombo();
        var limitToBBox = combo.getLimitToBBox();
        var map = BasiGX.util.Map.getMapComponent().getMap();
        var projection = map.getView().getProjection().getCode();
        var bbox;
        var bboxFilter;
        var visibleExtent = map.getView().calculateExtent(map.getSize());
        var maxFeatures = combo.getMaxFeatures();

        if (limitToBBox) {
            bbox = visibleExtent;
        }

        if (bbox) {
            var bboxll = bbox[0] + &#39; &#39; + bbox[1];
            var bboxur = bbox[2] + &#39; &#39; + bbox[3];
            bboxFilter =
                &#39;&lt;ogc:BBOX&gt;&#39; +
                    &#39;&lt;gml:Envelope srsName=&quot;&#39; + projection + &#39;&quot;&gt;&#39; +
                        &#39;&lt;gml:lowerCorner&gt;&#39; + bboxll + &#39;&lt;/gml:lowerCorner&gt;&#39; +
                        &#39;&lt;gml:upperCorner&gt;&#39; + bboxur + &#39;&lt;/gml:upperCorner&gt;&#39; +
                    &#39;&lt;/gml:Envelope&gt;&#39; +
                &#39;&lt;/ogc:BBOX&gt;&#39;;
        }

        var xml =
            &#39;&lt;wfs:GetFeature service=&quot;WFS&quot; version=&quot;1.1.0&quot; &#39; +
            &#39;outputFormat=&quot;application/json&quot; &#39; +
            &#39;maxFeatures=&quot;&#39; + maxFeatures + &#39;&quot; &#39; +
            &#39;xmlns:wfs=&quot;http://www.opengis.net/wfs&quot; &#39; +
            &#39;xmlns:ogc=&quot;http://www.opengis.net/ogc&quot; &#39; +
            &#39;xmlns:gml=&quot;http://www.opengis.net/gml&quot; &#39; +
            &#39;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &#39; +
            &#39;xsi:schemaLocation=&quot;http://www.opengis.net/wfs &#39; +
            &#39;http://schemas.opengis.net/wfs/1.1.0/WFS-basic.xsd&quot;&gt;&#39;;

        Ext.each(featureTypes, function(ft) {
            var searchableAttributes = me.findSearchableAttributes(ft);
            var props = ft.properties;
            if (searchableAttributes) {
                props = searchableAttributes;
            }
            Ext.each(props, function(prop) {
                var comparisonFilter;

                switch (prop.type) {
                    case &#39;xsd:string&#39;:
                        comparisonFilter =
                            &#39;&lt;ogc:PropertyIsLike wildCard=&quot;*&quot; singleChar=&quot;.&quot;&#39; +
                            &#39; escape=&quot;\\&quot; matchCase=&quot;false&quot;&gt;&#39; +
                                &#39;&lt;ogc:PropertyName&gt;&#39; +
                                    prop.name +
                                &#39;&lt;/ogc:PropertyName&gt;&#39; +
                                &#39;&lt;ogc:Literal&gt;&#39; +
                                    &#39;*&#39; + me.searchTerm + &#39;*&#39; +
                                &#39;&lt;/ogc:Literal&gt;&#39; +
                            &#39;&lt;/ogc:PropertyIsLike&gt;&#39;;
                        break;
                    // TODO add support for xsd:date
                    case &#39;xsd:int&#39;:
                    case &#39;xsd:number&#39;:
                        var type = &#39;java.lang.Double&#39;;
                        if (combo.getUseGeoServerStringExtension()) {
                            comparisonFilter =
                                &#39;&lt;ogc:PropertyIsLike wildCard=&quot;*&quot; &#39; +
                                    &#39;singleChar=&quot;.&quot; escape=&quot;\\&quot; &#39; +
                                    &#39;matchCase=&quot;false&quot;&gt;&#39; +
                                    &#39;&lt;ogc:Function name=&quot;stringFormat&quot;&gt;&#39; +
                                        &#39;&lt;ogc:Literal&gt;%f&lt;/ogc:Literal&gt;&#39; +
                                        &#39;&lt;ogc:Literal&gt;&#39; + type +
                                        &#39;&lt;/ogc:Literal&gt;&#39; +
                                        &#39;&lt;ogc:PropertyName&gt;&#39; + prop.name +
                                        &#39;&lt;/ogc:PropertyName&gt;&#39; +
                                    &#39;&lt;/ogc:Function&gt;&#39; +
                                    &#39;&lt;ogc:Literal&gt;&#39; +
                                        &#39;*&#39; + me.searchTerm.toLowerCase() +
                                        &#39;*&#39; +
                                    &#39;&lt;/ogc:Literal&gt;&#39; +
                                &#39;&lt;/ogc:PropertyIsLike&gt;&#39;;
                        } else {
                            comparisonFilter =
                                &#39;&lt;ogc:PropertyIsLike wildCard=&quot;*&quot; &#39; +
                                    &#39;singleChar=&quot;.&quot; escape=&quot;\\&quot; &#39; +
                                    &#39;matchCase=&quot;false&quot;&gt;&#39; +
                                    &#39;&lt;ogc:Function name=&quot;strTrim&quot;&gt;&#39; +
                                        &#39;&lt;ogc:PropertyName&gt;&#39; + prop.name +
                                        &#39;&lt;/ogc:PropertyName&gt;&#39; +
                                    &#39;&lt;/ogc:Function&gt;&#39; +
                                    &#39;&lt;ogc:Literal&gt;&#39; +
                                        &#39;*&#39; + me.searchTerm.toLowerCase() +
                                        &#39;*&#39; +
                                    &#39;&lt;/ogc:Literal&gt;&#39; +
                                &#39;&lt;/ogc:PropertyIsLike&gt;&#39;;
                        }
                        break;
                    default:
                        break;
                }
                if (comparisonFilter) {
                    var ns = (namespace || me.getCombo().getWfsPrefix()) + &#39;:&#39;;
                    var filter;
                    if (bboxFilter) {
                        filter = &#39;&lt;ogc:And&gt;&#39; +
                            bboxFilter +
                            comparisonFilter +
                            &#39;&lt;/ogc:And&gt;&#39;;
                    } else {
                        filter = comparisonFilter;
                    }
                    xml += &#39;&lt;wfs:Query typeName=&quot;&#39; + ns + ft.typeName +
                        &#39;&quot; srsName=&quot;&#39; + projection + &#39;&quot;&gt;&#39; +
                            &#39;&lt;ogc:Filter&gt;&#39; + filter + &#39;&lt;/ogc:Filter&gt;&#39; +
                        &#39;&lt;/wfs:Query&gt;&#39;;
                }
            });
        });

        xml += &#39;&lt;/wfs:GetFeature&gt;&#39;;

        return xml;
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-findSearchableAttributes'>    /**
</span>     * Tries to estimate feature attributes which should be used for WFS search.
     * This can be the case, if the layer is configured with custom property
     * `searchable` set to true and having an array of `searchColumns` as
     * further attribute.
     * If at least one of these condition is not filled, `false` will be
     * returned and the default behaviour (use all feature type attributes for
     * search) takes effect.
     *
     * @param {Object} featureType Object containing feature type name and its
     *     properties.
     *
     * @return {Array} Array of searchable attributes for given feature type
     */
    findSearchableAttributes: function(featureType) {
        var me = this;
        var combo = me.combo;
        var searchableAttributes = [];
        var searchLayers = combo.getAllSearchLayers();

        var ftName = featureType.typeName;
        var layer = searchLayers.find(function(l) {
            var layerName = l.getSource().getParams().LAYERS;
            return layerName &amp;&amp; layerName.indexOf(ftName) &gt; -1;
        });

        var searchable = layer &amp;&amp; layer.get(&#39;searchable&#39;) &amp;&amp;
            layer.get(&#39;searchColumns&#39;);

        if (searchable &amp;&amp; !Ext.isEmpty(layer.get(&#39;searchColumns&#39;))) {
            Ext.each(layer.get(&#39;searchColumns&#39;), function(sc) {
                var ft = featureType.properties.find(function(prop) {
                    return prop.name === sc;
                });
                if (ft &amp;&amp; ft.type) {
                    searchableAttributes.push({
                        name: sc,
                        type: ft.type
                    });
                }
            });
        }
        return searchable &amp;&amp; searchableAttributes;
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-showSearchResults'>    /**
</span>     * This method parses the features and adds them to the store to show the
     * search results in the grid.
     *
     * Called by getFeatureResponse event fired by successfull response of
     * the method #getFeatures.
     *
     * @param {Array&lt;ol.Feature&gt;} features The features.
     */
    showSearchResults: function(features) {
        var me = this;
        var combo = me.getCombo();
        var parser = new ol.format.GeoJSON();
        var searchLayers = combo.getAllSearchLayers();

        if (!features) {
            Ext.log.error(&#39;No feature found&#39;);
        } else {
            if (features.length === 0) {
                me.hide();
                combo.noWfsSearchResults = true;
            } else {
                me.show();
                combo.noWfsSearchResults = false;

                var searchTerm = me.searchTerm.toLowerCase();
                Ext.each(features, function(feature) {
                    var useCustomTemplate = false;
                    var ftName = feature.id &amp;&amp; feature.id.split(&#39;.&#39;)[0];
                    var layer;
                    if (ftName) {
                        layer = searchLayers.find(function(l) {
                            var layerName = l.getSource().getParams().LAYERS;
                            return layerName &amp;&amp; layerName.indexOf(ftName) &gt; -1;
                        });
                    }
                    if (layer) {
                        useCustomTemplate = layer &amp;&amp; layer.get(&#39;searchable&#39;) &amp;&amp;
                            layer.get(&#39;searchTemplate&#39;);
                    }

                    var displayfield;

                    if (useCustomTemplate) {
                        var templateUtil = BasiGX.util.StringTemplate;
                        displayfield = templateUtil.getTextFromTemplate(
                            feature, layer.get(&#39;searchTemplate&#39;),
                            me.getTemplateConfig()
                        );
                    } else {
                        // find the matching value in order to display it
                        Ext.iterate(feature.properties, function(k, v) {
                            var lcVal = v &amp;&amp; v.toString().toLowerCase();
                            if (lcVal &amp;&amp; lcVal.indexOf(searchTerm) &gt; -1) {
                                displayfield = v;
                                return false;
                            }
                        });
                    }

                    feature.properties.displayfield = displayfield;
                    if (me.getUseLayerName()) {
                        feature.properties.featuretype = layer.get(&#39;name&#39;);
                    } else {
                        feature.properties.featuretype = ftName;
                    }

                    var olFeat = parser.readFeatures(feature, {
                        dataProjection: combo.getWfsDataProjection(),
                        featureProjection: combo.getWfsFeatureProjection()
                    })[0];
                    me.searchResultVectorLayer.getSource().addFeature(olFeat);

                });
            }
            combo.fireEvent(&#39;checkresultsvisibility&#39;);
        }
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-onBoxReady'>    /**
</span>     * called by OnBoxready listener to add search layer
     */
    onBoxReady: function() {
        var me = this;
        if (!me.getMap()) {
            var map = BasiGX.util.Map.getMapComponent().getMap();
            me.setMap(map);
        }
        if (!me.getLayer()) {
            var layer = new ol.layer.Vector({
                source: new ol.source.Vector()
            });
            var displayInLayerSwitcherKey =
                BasiGX.util.Layer.KEY_DISPLAY_IN_LAYERSWITCHER;
            layer.set(displayInLayerSwitcherKey, false);
            me.setLayer(layer);
            me.getMap().addLayer(layer);
        }
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-highlightFeature'>    /**
</span>     * Called by onitemmouseenter listener to highlight the hovered search
     * results on the map.
     *
     * @param {Ext.grid.Panel} tableView The grid panel (`Ext.view.View`).
     * @param {Ext.data.Model} record The record that belongs to the item.
     */
    highlightFeature: function(tableView, record) {
        var me = this;
        var layer = me.getLayer();
        layer.getSource().clear();

        var feature = record.getFeature();

        if (feature) {
            BasiGX.util.Animate.flashFeature(feature, 1000, layer);
            feature.setStyle(me.getSearchResultHighlightFeatureStyle());
            layer.getSource().addFeature(feature);
        }
    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-unhighlightFeature'>    /**
</span>     * Called by onitemmouseleave listener to unhighlight the search
     * results on the map.
     *
     * @param {Ext.grid.Panel} tableView The grid panel (`Ext.view.View`).
     * @param {Ext.data.Model} record The record that belongs to the item.
     */
    unhighlightFeature: function(tableView, record) {
        var me = this;
        var layer = me.getLayer();
        layer.getSource().clear();

        var feature = record.getFeature();

        if (feature) {
            feature.setStyle(me.getSearchResultFeatureStyle());
        }

    },

<span id='BasiGX-view-grid-MultiSearchWFSSearchGrid-method-highlightSelectedFeature'>    /**
</span>     * Called by onitemclick listener to center map on clicked item.
     *
     * @param {Ext.grid.Panel} tableView The grid panel (`Ext.view.View`).
     * @param {Ext.data.Model} record The record that belongs to the item.
     */
    highlightSelectedFeature: function(tableView, record) {
        var me = this;
        var layer = me.getLayer();
        var feature = record.getFeature();
        var geom;
        var extent;
        var x;
        var y;
        var layerName = record.getData().featuretype;

        layer.getSource().clear();

        if (feature) {
            feature.setStyle(me.getSearchResultSelectFeatureStyle());
            layer.getSource().addFeature(feature);
            geom = feature.getGeometry();
            extent = geom.getExtent();
            x = extent[0] + (extent[2] - extent[0]) / 2;
            y = extent[1] + (extent[3] - extent[1]) / 2;

            var olView = me.getMap().getView();

            if (me.getZoomToSearchResults()) {
                var scale = me.getZoomToScale()[geom.getType().toLowerCase()];
                var zoom;
                if (scale) {
                    var units = olView.getProjection().getUnits();
                    zoom = BasiGX.util.Map.getResolutionForScale(scale, units);
                }
                olView.fit(geom, {
                    duration: 500,
                    zoom: zoom
                });
            } else {
                olView.setCenter([x, y]);
            }
        }
        // set layer visibility of clicked feature to true
        if (layerName) {
            var olLayer = BasiGX.util.Layer.getLayerByName(layerName);
            if (olLayer &amp;&amp; !olLayer.getVisible()) {
                olLayer.setVisible(true);
            }
        }
    }
});
</pre>
</body>
</html>
