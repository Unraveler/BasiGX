<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2017-present terrestris GmbH &amp; Co. KG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
<span id='BasiGX-view-container-SLDStyler'>/**
</span> * SLD Styler
 *
 * Used in combination with a GeoServer to edit SLD styles and preview
 * or save them
 *
 * @example:
 * var styleEditor = {
 *     xtype: &#39;basigx-container-sldstyler&#39;,
 *     backendUrls: {
 *        pictureList: {
 *            url: &#39;rest/images&#39;,
 *            method: &#39;GET&#39;
 *        },
 *        pictureSrc: {
 *            url: &#39;image/getThumbnail.action?id=&#39;
 *        },
 *        pictureUpload: {
 *            url: &#39;image/upload.action?&#39;
 *        },
 *        graphicDelete: {
 *            url: &#39;rest/images/&#39;,
 *            method: &#39;DELETE&#39;
 *        },
 *        geoServerUrl: BasiGX.util.Url.getWebProjectBaseUrl() +
 *            &#39;geoserver.action&#39;,
 *        internalUrl: &#39;http://shogun-webapp.internal/&#39;
 *     },
 *     layer: &#39;namespace:layer&#39;,
 *     sld: &#39;&lt;xml ...?&gt;&#39;,
 *     ruleName: &#39;rule1&#39;,
 *     mode: &#39;polygon&#39;
 * };
 *
 * @author Johannes Weskamm
 * @class BasiGX.view.container.SLDStyler
 */
Ext.define(&#39;BasiGX.view.container.SLDStyler&#39;, {
    extend: &#39;Ext.container.Container&#39;,
    xtype: &#39;basigx-container-sldstyler&#39;,

    requires: [
        &#39;Ext.ux.colorpick.Button&#39;,
        &#39;GeoExt.component.Map&#39;,
        &#39;BasiGX.view.panel.GraphicPool&#39;,
        &#39;BasiGX.view.panel.FontSymbolPool&#39;,
        &#39;BasiGX.util.Color&#39;,
        &#39;BasiGX.util.SLD&#39;,
        &#39;BasiGX.util.Object&#39;
    ],

<span id='BasiGX-view-container-SLDStyler-cfg-viewModel'>    viewModel: {
</span>        data: {
            pointStyleFieldSetTitle: &#39;Point Style&#39;,
            pointStyleSymbolPanelTitle: &#39;Symbol&#39;,
            pointStyleRadiusNumberFieldLabel: &#39;Point Radius&#39;,
            pointStyleStrokeNumberFieldLabel: &#39;Stroke Width&#39;,
            pointStyleStrokeColorFieldLabel: &#39;Stroke Color&#39;,
            pointStyleFillColorFieldLabel: &#39;Fill Color&#39;,
            pointStyleGraphicPanelTitle: &#39;Graphic&#39;,
            pointStyleChooseImgBtnText: &#39;Choose Image&#39;,
            pointStyleChooseFontBtnText: &#39;Choose Font Symbol&#39;,
            pointStyleImgScaleSliderLabel: &#39;Scale&#39;,
            pointStyleImgRotationSliderLabel: &#39;Rotation&#39;,
            pointStyleImgOpacitySliderLabel: &#39;Opacity&#39;,
            lineStyleFieldSetTitle: &#39;LineString Style&#39;,
            lineStyleStrokeNumberFieldLabel: &#39;Stroke Width&#39;,
            lineStyleStrokeColorFieldLabel: &#39;Stroke Color&#39;,
            polygonStyleFieldSetTitle: &#39;Polygon Style&#39;,
            polygonStyleSymbolPanelTitle: &#39;Symbol&#39;,
            polygonStyleStrokeNumberFieldLabel: &#39;Stroke Width&#39;,
            polygonStyleStrokeColorFieldLabel: &#39;Stroke Color&#39;,
            polygonStyleFillColorFieldLabel: &#39;Fill Color&#39;,
            polygonStyleGraphicPanelTitle: &#39;Graphic&#39;,
            polygonStyleImgScaleSliderLabel: &#39;Scale&#39;,
            polygonStyleImgRotationSliderLabel: &#39;Rotation&#39;,
            polygonStyleImgOpacitySliderLabel: &#39;Opacity&#39;,
            textStyleFieldSetTitle: &#39;Text Style&#39;,
            attributeSelectLabel: &#39;Attribute used for labels&#39;,
            textFontLabel: &#39;Font&#39;,
            textFontSizeLabel: &#39;Font size&#39;,
            fontStyleLabel: &#39;Font style&#39;,
            fontWeightLabel: &#39;Font weight&#39;,
            textFillColorFieldLabel: &#39;Text color&#39;,
            textPerpendicularOffsetLabel: &#39;Perpendicular Offset&#39;,
            textAnchorPointXLabel: &#39;Anchor Point X&#39;,
            textAnchorPointYLabel: &#39;Anchor Point Y&#39;,
            textDisplacementXLabel: &#39;Displacement X&#39;,
            textDisplacementYLabel: &#39;Displacement Y&#39;,
            textRotationLabel: &#39;Rotation&#39;,
            textFollowLineLabel: &#39;Follow Line&#39;,
            pointGrapicDeletedSuccessMsgText: &#39;The icon has been deleted. &#39; +
                &#39;Please reassign a new one.&#39;,
            pointGrapicDeletedSuccessMsgTitle: &#39;Deletion succesfull&#39;,
            graphicPoolWindowTitle: &#39;Graphic Pool&#39;,
            fontSymbolPoolWindowTitle: &#39;Font symbol pool&#39;,
            documentation: &#39;&lt;h2&gt;SLD Styler&lt;/h2&gt;• Verwenden Sie den &#39; +
                &#39;SLD Styler, um Ihre Zeichenobjekte nach Wunsch zu gestalten.&#39; +
                &#39;&lt;br&gt;• Neben Farben, Strichstärken und Schrifteigenschaften &#39; +
                &#39;können auch eigene Icons für die Symbolisierung verwendet &#39; +
                &#39;werden&#39;
        }
    },

<span id='BasiGX-view-container-SLDStyler-property-padding'>    /**
</span>     *
     */
    padding: 5,

<span id='BasiGX-view-container-SLDStyler-property-layout'>    /**
</span>     *
     */
    layout: &#39;hbox&#39;,

<span id='BasiGX-view-container-SLDStyler-property-config'>    /**
</span>     *
     */
    config: {
<span id='BasiGX-view-container-SLDStyler-cfg-backendUrls'>        /**
</span>         *
         */
        backendUrls: {
<span id='BasiGX-view-container-SLDStyler-property-pictureList'>            /**
</span>             * The URL to retrieve all images with resource link as JSON
             */
            pictureList: null,
<span id='BasiGX-view-container-SLDStyler-property-pictureSrc'>            /**
</span>             * The URL to retrieve an image as thumbnail
             */
            pictureSrc: null,
<span id='BasiGX-view-container-SLDStyler-property-pictureUpload'>            /**
</span>             * The URL to upload an image
             */
            pictureUpload: null,
<span id='BasiGX-view-container-SLDStyler-property-graphicDelete'>            /**
</span>             * The URL to delete an image
             */
            graphicDelete: null,
<span id='BasiGX-view-container-SLDStyler-property-geoServerUrl'>            /**
</span>             * The URL of the GeoServer to use
             */
            geoServerUrl: null,
<span id='BasiGX-view-container-SLDStyler-property-geoserverFontListUrl'>            /**
</span>             * The REST URL of the GeoServer to retrieve all available fonts.
             * E.g. http://localhost:8080/geoserver/rest/resource/fonts
             * would list all fonts from the GEOSERVER_DATA_DIR/fonts directory
             */
            geoserverFontListUrl: null,

<span id='BasiGX-view-container-SLDStyler-property-geoserverInstalledFontListUrl'>            /**
</span>             * The REST URL of the GeoServer to retrieve all installed fonts.
             * E.g. http://localhost:8080/geoserver/rest/fonts
             * would list all fonts available in GeoServer
             */
            geoserverInstalledFontListUrl: null,

<span id='BasiGX-view-container-SLDStyler-property-geoserverFontUrl'>            /**
</span>             * The REST URL of the GeoServer to retrieve a specific font. E.g.
             * http://localhost:8080/geoserver/rest/resource/fonts/Arial.ttf
             * would retrieve the specific font from the
             * GEOSERVER_DATA_DIR/fonts directory
             */
            geoserverFontUrl: null,

<span id='BasiGX-view-container-SLDStyler-property-internalUrl'>            /**
</span>             * If set, this URL is used when creating the SLD instead of the
             * BasiGX project base url from window.location.
             * @type {String}
             */
            internalUrl: null
        },
<span id='BasiGX-view-container-SLDStyler-cfg-mode'>        /**
</span>         * The mode indicates if we are styling a `point`, `line` or `polygon`
         */
        mode: &#39;point&#39;,

<span id='BasiGX-view-container-SLDStyler-cfg-layer'>        /**
</span>         * The full qualified layerName of the layer in GeoServer
         */
        layer: null,

<span id='BasiGX-view-container-SLDStyler-cfg-sld'>        /**
</span>         * The SLD this component shall use
         */
        sld: null,

<span id='BasiGX-view-container-SLDStyler-cfg-ruleName'>        /**
</span>         * The name of the rule of the SLD we want to handle
         */
        ruleName: null,

<span id='BasiGX-view-container-SLDStyler-cfg-rule'>        /**
</span>         * The rule Object. Gets set on update of style
         */
        rule: null,

<span id='BasiGX-view-container-SLDStyler-cfg-sldObj'>        /**
</span>         * The SLD javascript Object
         */
        sldObj: null,

<span id='BasiGX-view-container-SLDStyler-cfg-useTextSymbolizer'>        /**
</span>         * Flag to indicate if the user shall be able to configure labels
         */
        useTextSymbolizer: false,

<span id='BasiGX-view-container-SLDStyler-cfg-attributeStore'>        /**
</span>         * Store containing the attributes of the current layer in order
         * to let the user select a specific attribute for TextSymbolizers
         */
        attributeStore: Ext.create(&#39;Ext.data.Store&#39;, {
            fields: [&#39;name&#39;, &#39;value&#39;],
            sorters: [&#39;name&#39;]
        }),

<span id='BasiGX-view-container-SLDStyler-cfg-mapCentered'>        /**
</span>         * Flag to indicate if the preview map has already been centered
         * to a feature of the layer
         */
        mapCentered: false
    },

<span id='BasiGX-view-container-SLDStyler-method-initComponent'>    /**
</span>     * @param {Object} config The configuration object for the SLD styler.
     */
    initComponent: function() {
        var sld = this.getSld();
        if (!sld) {
            Ext.log.warn(&#39;Component needs to be configured with a valid SLD&#39;);
            return;
        }
        this.callParent();
        this.setSldObj(BasiGX.util.SLD.toSldObject(sld));
        var fs;
        if (this.getMode() === &#39;point&#39;) {
            fs = this.getPointFieldset();
        } else if (this.getMode() === &#39;line&#39;) {
            fs = this.getLineStringFieldset();
        } else if (this.getMode() === &#39;polygon&#39;) {
            fs = this.getPolygonFieldset();
        }
        var stylerAndMap = {
            xtype: &#39;container&#39;,
            layout: &#39;vbox&#39;,
            items: [
                fs,
                this.createSLDPreviewMap()
            ]
        };
        this.add(stylerAndMap);

        if (this.getUseTextSymbolizer()) {
            this.add(this.getTextSymbolizerFieldset());
        }

        // activate the graphic tab if necessary
        var usingExternalGraphic = false;
        var graphicOrMark = BasiGX.util.Object.getValue(
            &#39;externalGraphicOrMark&#39;, this.getSldObj());
        if (graphicOrMark &amp;&amp; graphicOrMark[0] &amp;&amp;
           (graphicOrMark[0].onlineResource ||
           (graphicOrMark[0].wellKnownName &amp;&amp;
            graphicOrMark[0].wellKnownName.content[0]
                .indexOf(&#39;ttf://&#39;) &gt; -1))) {
            usingExternalGraphic = true;
        }
        if (usingExternalGraphic) {
            var externalGrphicPanel = this.down(&#39;panel[name=graphic]&#39;);
            this.down(&#39;tabpanel&#39;).setActiveItem(externalGrphicPanel);
        }
        this.updateSLDPreview();
    },

<span id='BasiGX-view-container-SLDStyler-method-getPointFieldset'>    /**
</span>     * Returns a configuration object for an ExtJS fieldset for styling points
     * which can e.g. be used inside the `items` config.
     *
     * @return {Object} A configuration for an ExtJS fieldset for styling
     *     points.
     */
    getPointFieldset: function() {
        var me = this;
        var sldObj = me.getSldObj();
        var getVal = BasiGX.util.Object.getValue;
        var rule = BasiGX.util.SLD.getRuleByName(me.getRuleName(), sldObj);
        var listenerConfig = {
            change: me.updateSLDPreview,
            scope: me
        };

        if (!rule) {
            // take the first available rule to show an initial render
            // for e.g. new created rules that are not persisted yet
            var availableRules = BasiGX.util.SLD.rulesFromSldObject(sldObj);
            rule = availableRules[0];
        }

        var strokeWidth = BasiGX.util.SLD.DEFAULT_STROKE_WIDTH;
        var strokeOpacity = BasiGX.util.SLD.DEFAULT_STROKE_OPACITY;
        var strokeColor = BasiGX.util.SLD.DEFAULT_STROKE_COLOR;
        var fillColor = BasiGX.util.SLD.DEFAULT_FILL_COLOR;
        var fillOpacity = BasiGX.util.SLD.DEFAULT_FILL_OPACITY;
        var radius = BasiGX.util.SLD.DEFAULT_POINT_RADIUS;
        var graphicSize = BasiGX.util.SLD.DEFAULT_GRAPHIC_SIZE;
        var graphicOpacity = BasiGX.util.SLD.DEFAULT_GRAPHIC_OPACITY * 100;
        var graphicRotation = BasiGX.util.SLD.DEFAULT_GRAPHIC_ROTATION;
        var externalGraphicSrc = null;
        var fontAndUniCode = null;
        var alpha;

        var fill = getVal(&#39;fill&#39;, rule);
        var stroke = getVal(&#39;stroke&#39;, rule);
        var size = getVal(&#39;size&#39;, rule);
        var graphic = getVal(&#39;graphic&#39;, rule);

        if (fill) {
            fillColor = BasiGX.util.SLD.fillFromObj(fill).fillColor;
            fillOpacity = BasiGX.util.SLD.fillFromObj(fill).fillOpacity;
            alpha = BasiGX.util.Color.makeHex(&#39;&#39; +
                Math.round(parseFloat(fillOpacity) * 255));
            fillColor = fillColor + alpha;
        }

        if (stroke) {
            strokeWidth = BasiGX.util.SLD.strokeFromObj(stroke).strokeWidth;
            strokeOpacity = BasiGX.util.SLD.strokeFromObj(stroke).strokeOpacity;
            strokeColor = BasiGX.util.SLD.strokeFromObj(stroke).strokeColor;
            alpha = BasiGX.util.Color.makeHex(&#39;&#39; +
                Math.round(parseFloat(strokeOpacity) * 255));
            strokeColor = strokeColor + alpha;
        }

        if (size) {
            radius = parseInt(size.content[0], 10);
        }

        if (graphic) {
            if (getVal(&#39;size&#39;, graphic)) {
                graphicSize = getVal(&#39;size&#39;, graphic).content[0];
            }
            if (getVal(&#39;opacity&#39;, graphic)) {
                graphicOpacity = getVal(&#39;opacity&#39;, graphic).content[0] * 100;
            }
            if (getVal(&#39;rotation&#39;, graphic)) {
                graphicRotation = getVal(&#39;rotation&#39;, graphic).content[0];
            }
            if (getVal(&#39;href&#39;, graphic)) {
                externalGraphicSrc = getVal(&#39;href&#39;, graphic);
            }
            if (getVal(&#39;wellKnownName&#39;, graphic)) {
                var content = getVal(&#39;wellKnownName&#39;, graphic).content[0];
                if (content.indexOf(&#39;ttf://&#39;) &gt; -1) {
                    fontAndUniCode = getVal(&#39;wellKnownName&#39;, graphic)
                        .content[0];
                }
            }
        }

        var fs = {
            xtype: &#39;fieldset&#39;,
            bind: {
                title: &#39;{pointStyleFieldSetTitle}&#39;
            },
            name: &#39;pointstyle&#39;,
            layout: &#39;hbox&#39;,
            items: [{
                xtype: &#39;tabpanel&#39;,
                items: [{
                    xtype: &#39;panel&#39;,
                    bind: {
                        title: &#39;{pointStyleSymbolPanelTitle}&#39;
                    },
                    defaults: {
                        margin: 3,
                        width: 220
                    },
                    items: [{
                        xtype: &#39;numberfield&#39;,
                        bind: {
                            fieldLabel: &#39;{pointStyleRadiusNumberFieldLabel}&#39;
                        },
                        name: &#39;radius&#39;,
                        value: radius,
                        minValue: 1,
                        maxValue: 50,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;numberfield&#39;,
                        bind: {
                            fieldLabel: &#39;{pointStyleStrokeNumberFieldLabel}&#39;
                        },
                        name: &#39;stroke-width&#39;,
                        value: strokeWidth,
                        minValue: 0,
                        maxValue: 50,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;container&#39;,
                        layout: &#39;hbox&#39;,
                        defaults: {
                            width: 100
                        },
                        items: [{
                            xtype: &#39;displayfield&#39;,
                            width: 100,
                            bind: {
                                value: &#39;{pointStyleStrokeColorFieldLabel}&#39;
                            }
                        }, {
                            xtype: &#39;colorbutton&#39;,
                            name: &#39;stroke&#39;,
                            format: &#39;hex8&#39;,
                            value: strokeColor,
                            margin: &#39;5 0 0 10&#39;,
                            listeners: listenerConfig
                        }]
                    }, {
                        xtype: &#39;container&#39;,
                        layout: &#39;hbox&#39;,
                        defaults: {
                            width: 100
                        },
                        items: [{
                            xtype: &#39;displayfield&#39;,
                            width: 100,
                            bind: {
                                value: &#39;{pointStyleFillColorFieldLabel}&#39;
                            }
                        }, {
                            xtype: &#39;colorbutton&#39;,
                            name: &#39;fill&#39;,
                            format: &#39;hex8&#39;,
                            margin: &#39;0 0 0 10&#39;,
                            value: fillColor,
                            listeners: listenerConfig
                        }]
                    }]
                }, {
                    xtype: &#39;panel&#39;,
                    bind: {
                        title: &#39;{pointStyleGraphicPanelTitle}&#39;
                    },
                    name: &#39;graphic&#39;,
                    externalGraphicSrc: externalGraphicSrc,
                    fontAndUniCode: fontAndUniCode,
                    defaults: {
                        margin: 3,
                        width: 220
                    },
                    layout: &#39;vbox&#39;,
                    items: [{
                        xtype: &#39;button&#39;,
                        bind: {
                            text: &#39;{pointStyleChooseImgBtnText}&#39;
                        },
                        handler: me.onChooseGraphicClick,
                        scope: me
                    }, {
                        xtype: &#39;button&#39;,
                        bind: {
                            text: &#39;{pointStyleChooseFontBtnText}&#39;
                        },
                        handler: me.onChooseFontClick,
                        scope: me
                    }, {
                        xtype: &#39;slider&#39;,
                        bind: {
                            fieldLabel: &#39;{pointStyleImgOpacitySliderLabel}&#39;
                        },
                        name: &#39;graphic-opacity&#39;,
                        value: graphicOpacity,
                        disabled: fontAndUniCode ? true : false,
                        minValue: 0,
                        maxValue: 100,
                        increment: 10,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;slider&#39;,
                        bind: {
                            fieldLabel: &#39;{pointStyleImgRotationSliderLabel}&#39;
                        },
                        name: &#39;graphic-rotation&#39;,
                        value: graphicRotation,
                        minValue: 0,
                        maxValue: 360,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;slider&#39;,
                        bind: {
                            fieldLabel: &#39;{pointStyleImgScaleSliderLabel}&#39;
                        },
                        name: &#39;graphic-scale&#39;,
                        value: graphicSize,
                        increment: 1,
                        minValue: 1,
                        maxValue: 100,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;slider&#39;,
                        bind: {
                            fieldLabel: &#39;{pointStyleStrokeNumberFieldLabel}&#39;
                        },
                        name: &#39;stroke-width&#39;,
                        value: strokeWidth,
                        disabled: externalGraphicSrc ? true : false,
                        minValue: 0,
                        maxValue: 50,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;container&#39;,
                        layout: &#39;hbox&#39;,
                        defaults: {
                            width: 100
                        },
                        items: [{
                            xtype: &#39;displayfield&#39;,
                            disabled: externalGraphicSrc ? true : false,
                            width: 100,
                            bind: {
                                value: &#39;{pointStyleStrokeColorFieldLabel}&#39;
                            }
                        }, {
                            xtype: &#39;colorbutton&#39;,
                            disabled: externalGraphicSrc ? true : false,
                            name: &#39;stroke&#39;,
                            format: &#39;hex8&#39;,
                            value: strokeColor,
                            margin: &#39;5 0 0 10&#39;,
                            listeners: listenerConfig
                        }]
                    }, {
                        xtype: &#39;container&#39;,
                        layout: &#39;hbox&#39;,
                        disabled: externalGraphicSrc ? true : false,
                        defaults: {
                            width: 100
                        },
                        items: [{
                            xtype: &#39;displayfield&#39;,
                            disabled: externalGraphicSrc ? true : false,
                            width: 100,
                            bind: {
                                value: &#39;{pointStyleFillColorFieldLabel}&#39;
                            }
                        }, {
                            xtype: &#39;colorbutton&#39;,
                            disabled: externalGraphicSrc ? true : false,
                            name: &#39;fill&#39;,
                            format: &#39;hex8&#39;,
                            margin: &#39;0 0 0 10&#39;,
                            value: fillColor,
                            listeners: listenerConfig
                        }]
                    }]
                }]
            }]
        };
        return fs;
    },

<span id='BasiGX-view-container-SLDStyler-method-getLineStringFieldset'>    /**
</span>     * Returns a configuration object for an ExtJS fieldset for styling
     * linestrings which can e.g. be used inside the `items` config.
     *
     * @return {Object} A configuration for an ExtJS fieldset for styling
     *     linestrings.
     */
    getLineStringFieldset: function() {
        var me = this;
        var sldObj = me.getSldObj();
        var getVal = BasiGX.util.Object.getValue;
        var rule = BasiGX.util.SLD.getRuleByName(me.getRuleName(), sldObj);
        var listenerConfig = {
            change: me.updateSLDPreview,
            scope: me
        };

        if (!rule) {
            // take the first available rule to show an initial render
            // for e.g. new created rules that are not persisted yet
            var availableRules = BasiGX.util.SLD.rulesFromSldObject(sldObj);
            rule = availableRules[0];
        }

        var strokeWidth = BasiGX.util.SLD.DEFAULT_STROKE_WIDTH;
        var strokeOpacity = BasiGX.util.SLD.DEFAULT_STROKE_OPACITY;
        var strokeColor = BasiGX.util.SLD.DEFAULT_STROKE_COLOR;

        var stroke = getVal(&#39;stroke&#39;, rule);

        if (stroke) {
            strokeWidth = BasiGX.util.SLD.strokeFromObj(stroke).strokeWidth;
            strokeOpacity = BasiGX.util.SLD.strokeFromObj(stroke).strokeOpacity;
            strokeColor = BasiGX.util.SLD.strokeFromObj(stroke).strokeColor;
            var alpha = BasiGX.util.Color.makeHex(&#39;&#39; +
                Math.round(parseFloat(strokeOpacity) * 255));
            strokeColor = strokeColor + alpha;
        }

        var fs = {
            xtype: &#39;fieldset&#39;,
            bind: {
                title: &#39;{lineStyleFieldSetTitle}&#39;
            },
            name: &#39;linestyle&#39;,
            layout: &#39;hbox&#39;,
            items: [{
                xtype: &#39;fieldset&#39;,
                layout: &#39;vbox&#39;,
                width: 220,
                defaults: {
                    margin: 3,
                    width: 180
                },
                items: [{
                    xtype: &#39;numberfield&#39;,
                    bind: {
                        fieldLabel: &#39;{lineStyleStrokeNumberFieldLabel}&#39;
                    },
                    value: strokeWidth,
                    name: &#39;stroke-width&#39;,
                    minValue: 0,
                    maxValue: 50,
                    listeners: listenerConfig
                }, {
                    xtype: &#39;container&#39;,
                    layout: &#39;hbox&#39;,
                    defaults: {
                        width: 100
                    },
                    items: [{
                        xtype: &#39;displayfield&#39;,
                        width: 100,
                        bind: {
                            value: &#39;{lineStyleStrokeColorFieldLabel}&#39;
                        }
                    }, {
                        xtype: &#39;colorbutton&#39;,
                        format: &#39;hex8&#39;,
                        value: strokeColor,
                        name: &#39;stroke&#39;,
                        margin: &#39;5 0 0 10&#39;,
                        listeners: listenerConfig
                    }]
                }]
            }]
        };
        return fs;
    },

<span id='BasiGX-view-container-SLDStyler-method-getPolygonFieldset'>    /**
</span>     * Returns a configuration object for an ExtJS fieldset for styling
     * polygons which can e.g. be used inside the `items` config.
     *
     * @return {Object} A configuration for an ExtJS fieldset for styling
     *     polygon.
     */
    getPolygonFieldset: function() {
        var me = this;
        var sldObj = me.getSldObj();
        var getVal = BasiGX.util.Object.getValue;
        var rule = BasiGX.util.SLD.getRuleByName(me.getRuleName(), sldObj);
        var listenerConfig = {
            change: me.updateSLDPreview,
            scope: me
        };

        if (!rule) {
            // take the first available rule to show an initial render
            // for e.g. new created rules that are not persisted yet
            var availableRules = BasiGX.util.SLD.rulesFromSldObject(sldObj);
            rule = availableRules[0];
        }

        var strokeWidth = BasiGX.util.SLD.DEFAULT_STROKE_WIDTH;
        var strokeOpacity = BasiGX.util.SLD.DEFAULT_STROKE_OPACITY;
        var strokeColor = BasiGX.util.SLD.DEFAULT_STROKE_COLOR;
        var fillColor = BasiGX.util.SLD.DEFAULT_FILL_COLOR;
        var fillOpacity = BasiGX.util.SLD.DEFAULT_FILL_OPACITY;
        var graphicSize = BasiGX.util.SLD.DEFAULT_GRAPHIC_SIZE;
        var graphicOpacity = BasiGX.util.SLD.DEFAULT_GRAPHIC_OPACITY * 100;
        var graphicRotation = BasiGX.util.SLD.DEFAULT_GRAPHIC_ROTATION;
        var externalGraphicSrc = null;
        var fontAndUniCode = null;
        var alpha;

        var fill = getVal(&#39;fill&#39;, rule);
        var stroke = getVal(&#39;stroke&#39;, rule);
        var graphic = getVal(&#39;graphic&#39;, rule);

        if (fill) {
            fillColor = BasiGX.util.SLD.fillFromObj(fill).fillColor;
            fillOpacity = BasiGX.util.SLD.fillFromObj(fill).fillOpacity;
            alpha = BasiGX.util.Color.makeHex(&#39;&#39; +
                Math.round(parseFloat(fillOpacity) * 255));
            fillColor = fillColor + alpha;
        }

        if (stroke) {
            strokeWidth = BasiGX.util.SLD.strokeFromObj(stroke).strokeWidth;
            strokeOpacity = BasiGX.util.SLD.strokeFromObj(stroke).strokeOpacity;
            strokeColor = BasiGX.util.SLD.strokeFromObj(stroke).strokeColor;
            alpha = BasiGX.util.Color.makeHex(&#39;&#39; +
                Math.round(parseFloat(strokeOpacity) * 255));
            strokeColor = strokeColor + alpha;
        }

        if (graphic) {
            if (getVal(&#39;size&#39;, graphic)) {
                graphicSize = getVal(&#39;size&#39;, graphic).content[0];
            }
            if (getVal(&#39;opacity&#39;, graphic)) {
                graphicOpacity = getVal(&#39;opacity&#39;, graphic).content[0] * 100;
            }
            if (getVal(&#39;rotation&#39;, graphic)) {
                graphicRotation = getVal(&#39;rotation&#39;, graphic).content[0];
            }
            if (getVal(&#39;href&#39;, graphic)) {
                externalGraphicSrc = getVal(&#39;href&#39;, graphic);
            }
            if (getVal(&#39;wellKnownName&#39;, graphic)) {
                var content = getVal(&#39;wellKnownName&#39;, graphic).content[0];
                if (content.indexOf(&#39;ttf://&#39;) &gt; -1) {
                    fontAndUniCode = getVal(&#39;wellKnownName&#39;, graphic)
                        .content[0];
                }
            }
        }

        var fs = {
            xtype: &#39;fieldset&#39;,
            bind: {
                title: &#39;{polygonStyleFieldSetTitle}&#39;
            },
            name: &#39;polygonstyle&#39;,
            layout: &#39;hbox&#39;,
            items: [{
                xtype: &#39;tabpanel&#39;,
                items: [{
                    xtype: &#39;panel&#39;,
                    bind: {
                        title: &#39;{polygonStyleSymbolPanelTitle}&#39;
                    },
                    layout: &#39;vbox&#39;,
                    width: 220,
                    defaults: {
                        margin: 3,
                        width: 210
                    },
                    items: [{
                        xtype: &#39;numberfield&#39;,
                        bind: {
                            fieldLabel: &#39;{polygonStyleStrokeNumberFieldLabel}&#39;
                        },
                        value: strokeWidth,
                        name: &#39;stroke-width&#39;,
                        allowDecimals: true,
                        decimalPrecision: 1,
                        decimalSeparator: &#39;.&#39;,
                        minValue: 0,
                        maxValue: 50,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;container&#39;,
                        layout: &#39;hbox&#39;,
                        defaults: {
                            width: 100
                        },
                        items: [{
                            xtype: &#39;displayfield&#39;,
                            width: 100,
                            bind: {
                                value: &#39;{polygonStyleStrokeColorFieldLabel}&#39;
                            }
                        }, {
                            xtype: &#39;colorbutton&#39;,
                            format: &#39;hex8&#39;,
                            value: strokeColor,
                            name: &#39;stroke&#39;,
                            margin: &#39;5 0 0 10&#39;,
                            listeners: listenerConfig
                        }]
                    }, {
                        xtype: &#39;container&#39;,
                        layout: &#39;hbox&#39;,
                        defaults: {
                            width: 100
                        },
                        items: [{
                            xtype: &#39;displayfield&#39;,
                            width: 100,
                            bind: {
                                value: &#39;{polygonStyleFillColorFieldLabel}&#39;
                            }
                        }, {
                            xtype: &#39;colorbutton&#39;,
                            format: &#39;hex8&#39;,
                            margin: &#39;0 0 0 10&#39;,
                            value: fillColor,
                            name: &#39;fill&#39;,
                            listeners: listenerConfig
                        }]
                    }]
                }, {
                    xtype: &#39;panel&#39;,
                    bind: {
                        title: &#39;{polygonStyleGraphicPanelTitle}&#39;
                    },
                    name: &#39;graphic&#39;,
                    layout: &#39;vbox&#39;,
                    externalGraphicSrc: externalGraphicSrc,
                    fontAndUniCode: fontAndUniCode,
                    defaults: {
                        margin: 3,
                        width: 210
                    },
                    items: [{
                        xtype: &#39;button&#39;,
                        bind: {
                            text: &#39;{pointStyleChooseImgBtnText}&#39;
                        },
                        handler: me.onChooseGraphicClick,
                        scope: me
                    }, {
                        xtype: &#39;button&#39;,
                        bind: {
                            text: &#39;{pointStyleChooseFontBtnText}&#39;
                        },
                        handler: me.onChooseFontClick,
                        scope: me
                    },
                    // opacity seems to be unsupported for external graphics /
                    // graphic fills, although its valid in SLD.
                    {
                        xtype: &#39;slider&#39;,
                        bind: {
                            fieldLabel: &#39;{polygonStyleImgOpacitySliderLabel}&#39;
                        },
                        name: &#39;graphic-opacity&#39;,
                        value: graphicOpacity,
                        disabled: true,
                        minValue: 0,
                        maxValue: 100,
                        increment: 10,
                        listeners: listenerConfig
                    },
                    {
                        xtype: &#39;slider&#39;,
                        bind: {
                            fieldLabel: &#39;{polygonStyleImgRotationSliderLabel}&#39;
                        },
                        name: &#39;graphic-rotation&#39;,
                        value: graphicRotation,
                        disabled: externalGraphicSrc ? true : false,
                        minValue: 0,
                        maxValue: 360,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;slider&#39;,
                        bind: {
                            fieldLabel: &#39;{polygonStyleImgScaleSliderLabel}&#39;
                        },
                        name: &#39;graphic-scale&#39;,
                        value: graphicSize,
                        increment: 1,
                        minValue: 1,
                        maxValue: 200,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;slider&#39;,
                        bind: {
                            fieldLabel: &#39;{polygonStyleStrokeNumberFieldLabel}&#39;
                        },
                        name: &#39;stroke-width&#39;,
                        value: strokeWidth,
                        disabled: externalGraphicSrc ? true : false,
                        minValue: 0,
                        maxValue: 10,
                        listeners: listenerConfig
                    }, {
                        xtype: &#39;container&#39;,
                        layout: &#39;hbox&#39;,
                        defaults: {
                            width: 100
                        },
                        items: [{
                            xtype: &#39;displayfield&#39;,
                            disabled: externalGraphicSrc ? true : false,
                            width: 100,
                            bind: {
                                value: &#39;{polygonStyleStrokeColorFieldLabel}&#39;
                            }
                        }, {
                            xtype: &#39;colorbutton&#39;,
                            disabled: externalGraphicSrc ? true : false,
                            name: &#39;stroke&#39;,
                            format: &#39;hex8&#39;,
                            value: strokeColor,
                            margin: &#39;5 0 0 10&#39;,
                            listeners: listenerConfig
                        }]
                    }, {
                        xtype: &#39;container&#39;,
                        layout: &#39;hbox&#39;,
                        defaults: {
                            width: 100
                        },
                        items: [{
                            xtype: &#39;displayfield&#39;,
                            disabled: externalGraphicSrc ? true : false,
                            width: 100,
                            bind: {
                                value: &#39;{polygonStyleFillColorFieldLabel}&#39;
                            }
                        }, {
                            xtype: &#39;colorbutton&#39;,
                            disabled: externalGraphicSrc ? true : false,
                            name: &#39;fill&#39;,
                            format: &#39;hex8&#39;,
                            margin: &#39;0 0 0 10&#39;,
                            value: fillColor,
                            listeners: listenerConfig
                        }]
                    }]
                }]
            }]
        };
        return fs;
    },

<span id='BasiGX-view-container-SLDStyler-method-getTextSymbolizerFieldset'>    /**
</span>     * Creates a fieldset containing UI elements to configure a textsymbolizer
     *
     * @return {Object} A configuration for an ExtJS fieldset for styling
     *     labels.
     */
    getTextSymbolizerFieldset: function() {
        var me = this;
        var sldObj = me.getSldObj();
        var getVal = BasiGX.util.Object.getValue;
        var rule = BasiGX.util.SLD.getRuleByName(me.getRuleName(), sldObj);
        var listenerConfig = {
            change: me.updateSLDPreview,
            scope: me
        };

        if (!rule) {
            // take the first available rule to show an initial render
            // for e.g. new created rules that are not persisted yet
            var availableRules = BasiGX.util.SLD.rulesFromSldObject(sldObj);
            rule = availableRules[0];
        }

        var labelAttribute = BasiGX.util.SLD.DEFAULT_LABEL_ATTRIBUTE;
        var fontSize = BasiGX.util.SLD.DEFAULT_FONTSIZE;
        var fontFamily = BasiGX.util.SLD.DEFAULT_FONT_FAMILY;
        var fontWeight = BasiGX.util.SLD.DEFAULT_FONT_WEIGHT;
        var fontStyle = BasiGX.util.SLD.DEFAULT_FONT_STYLE;
        var fontFillColor = BasiGX.util.SLD.DEFAULT_FONT_FILLCOLOR;
        var perpendicularOffset = BasiGX.util.SLD.
            DEFAULT_LABEL_PERPENDICULAROFFSET;
        var labelAnchorPointX = BasiGX.util.SLD.DEFAULT_LABEL_ANCHORPOINTX;
        var labelAnchorPointY = BasiGX.util.SLD.DEFAULT_LABEL_ANCHORPOINTY;
        var labelDisplacementX = BasiGX.util.SLD.DEFAULT_LABEL_DISPLACEMENTX;
        var labelDisplacementY = BasiGX.util.SLD.DEFAULT_LABEL_DISPLACEMENTY;
        var labelRotation = BasiGX.util.SLD.DEFAULT_LABEL_ROTATION;
        var followLineLabel = BasiGX.util.SLD.DEFAULT_LABEL_FOLLOW_LINE;
        var textSymbolizer;
        var checkboxToggled = false;

        Ext.each(rule.symbolizer, function(sym) {
            if (sym.name.localPart === &#39;TextSymbolizer&#39;) {
                textSymbolizer = sym.value;
            }
        });

        if (textSymbolizer) {
            checkboxToggled = true;
            var font = getVal(&#39;font&#39;, textSymbolizer);
            labelAttribute = getVal(&#39;value&#39;, textSymbolizer.label) ?
                getVal(&#39;value&#39;, textSymbolizer.label).content[0] :
                BasiGX.util.SLD.DEFAULT_LABEL_ATTRIBUTE;
            Ext.each(font.cssParameter, function(param) {
                if (param.name === &#39;font-family&#39;) {
                    fontFamily = param.content[0];
                } else if (param.name === &#39;font-size&#39;) {
                    fontSize = param.content[0];
                } else if (param.name === &#39;font-style&#39;) {
                    fontStyle = param.content[0];
                } else if (param.name === &#39;font-weight&#39;) {
                    fontWeight = param.content[0];
                }
            });
            var fill = getVal(&#39;fill&#39;, textSymbolizer);
            if (fill) {
                fontFillColor = BasiGX.util.SLD.fillFromObj(fill).fillColor;
                var fillOpacity = BasiGX.util.SLD.fillFromObj(fill).fillOpacity;
                var alpha = BasiGX.util.Color.makeHex(&#39;&#39; +
                    Math.round(parseFloat(fillOpacity) * 255));
                fontFillColor = fontFillColor + alpha;
            }
            var pointPlacement = getVal(&#39;pointPlacement&#39;, textSymbolizer);
            if (pointPlacement) {
                if (pointPlacement.anchorPoint &amp;&amp;
                    pointPlacement.anchorPoint.anchorPointX) {
                    labelAnchorPointX = pointPlacement.anchorPoint.
                        anchorPointX.content[0];
                }
                if (pointPlacement.anchorPoint &amp;&amp;
                    pointPlacement.anchorPoint.anchorPointY) {
                    labelAnchorPointY = pointPlacement.anchorPoint.
                        anchorPointY.content[0];
                }
                if (pointPlacement.displacement &amp;&amp;
                    pointPlacement.displacement.displacementX) {
                    labelDisplacementX = pointPlacement.displacement.
                        displacementX.content[0];
                }
                if (pointPlacement.displacement &amp;&amp;
                    pointPlacement.displacement.displacementY) {
                    labelDisplacementY = pointPlacement.displacement.
                        displacementY.content[0];
                }
                if (pointPlacement.rotation) {
                    labelRotation = pointPlacement.rotation.content[0];
                }
            }
            var linePlacement = getVal(&#39;linePlacement&#39;, textSymbolizer);
            if (linePlacement &amp;&amp; linePlacement.perpendicularOffset) {
                perpendicularOffset = linePlacement.perpendicularOffset.
                    content[0];
            }
            var vendorOptions = getVal(&#39;vendorOption&#39;, textSymbolizer);
            if (vendorOptions) {
                Ext.each(vendorOptions, function(option) {
                    if (option.name === &#39;followLine&#39;) {
                        followLineLabel = option.value === &#39;true&#39; ?
                            true : false;
                    }
                });
            }
        }

        var fontStore = Ext.create(&#39;Ext.data.Store&#39;, {
            autoLoad: true,
            proxy: {
                type: &#39;ajax&#39;,
                url: me.getBackendUrls().geoserverInstalledFontListUrl,
                reader: {
                    type: &#39;json&#39;,
                    rootProperty: function(data) {
                        var fontCollection = [];
                        Ext.each(data.fonts, function(singleFont, idx) {
                            fontCollection[idx] = {name: singleFont};
                        });
                        return fontCollection;
                    }
                }
            },
            fields: [&#39;name&#39;],
            sorters: [&#39;name&#39;]
        });
        var fontStyleStore = Ext.create(&#39;Ext.data.Store&#39;, {
            fields: [&#39;name&#39;],
            sorters: [&#39;name&#39;],
            data: [{
                name: &#39;normal&#39;
            }, {
                name: &#39;italic&#39;
            }, {
                name: &#39;oblique&#39;
            }]
        });
        var fontWeightStore = Ext.create(&#39;Ext.data.Store&#39;, {
            fields: [&#39;name&#39;],
            sorters: [&#39;name&#39;],
            data: [{
                name: &#39;normal&#39;
            }, {
                name: &#39;bold&#39;
            }]
        });
        var fs = {
            xtype: &#39;fieldset&#39;,
            checkboxToggle: true,
            checkbox: {
                // Note: Setting the listeners overwrites the default collapse
                // behavior. In this case it&#39;s wanted, but to keep the default
                // toggling the handler config has to be used instead
                listeners: listenerConfig,
                checked: checkboxToggled
            },
            height: &#39;100%&#39;,
            bind: {
                title: &#39;{textStyleFieldSetTitle}&#39;
            },
            name: &#39;textsymbolizer&#39;,
            defaults: {
                width: 400
            },
            items: [{
                xtype: &#39;combo&#39;,
                name: &#39;labelattribute&#39;,
                store: me.attributeStore,
                displayField: &#39;name&#39;,
                queryMode: &#39;local&#39;,
                bind: {
                    fieldLabel: &#39;{attributeSelectLabel}&#39;
                },
                value: labelAttribute,
                listeners: listenerConfig
            }, {
                xtype: &#39;combo&#39;,
                name: &#39;fontfamily&#39;,
                bind: {
                    fieldLabel: &#39;{textFontLabel}&#39;
                },
                store: fontStore,
                value: fontFamily,
                queryMode: &#39;local&#39;,
                displayField: &#39;name&#39;,
                listeners: listenerConfig
            }, {
                xtype: &#39;combo&#39;,
                bind: {
                    fieldLabel: &#39;{fontStyleLabel}&#39;
                },
                name: &#39;fontstyle&#39;,
                store: fontStyleStore,
                value: fontStyle,
                queryMode: &#39;local&#39;,
                displayField: &#39;name&#39;,
                listeners: listenerConfig
            }, {
                xtype: &#39;combo&#39;,
                bind: {
                    fieldLabel: &#39;{fontWeightLabel}&#39;
                },
                name: &#39;fontweight&#39;,
                store: fontWeightStore,
                value: fontWeight,
                queryMode: &#39;local&#39;,
                displayField: &#39;name&#39;,
                listeners: listenerConfig
            }, {
                xtype: &#39;numberfield&#39;,
                bind: {
                    fieldLabel: &#39;{textFontSizeLabel}&#39;
                },
                value: fontSize,
                name: &#39;fontsize&#39;,
                minValue: 1,
                maxValue: 50,
                listeners: listenerConfig
            }, {
                xtype: &#39;container&#39;,
                layout: &#39;hbox&#39;,
                defaults: {
                    width: 100
                },
                items: [{
                    xtype: &#39;displayfield&#39;,
                    width: 100,
                    bind: {
                        value: &#39;{textFillColorFieldLabel}&#39;
                    }
                }, {
                    xtype: &#39;colorbutton&#39;,
                    name: &#39;fill&#39;,
                    format: &#39;hex8&#39;,
                    margin: &#39;5 0 0 5&#39;,
                    value: fontFillColor,
                    listeners: listenerConfig
                }]
            }]
        };
        if (this.getMode() === &#39;line&#39;) {
            fs.items.push({
                xtype: &#39;numberfield&#39;,
                bind: {
                    fieldLabel: &#39;{textPerpendicularOffsetLabel}&#39;
                },
                value: perpendicularOffset,
                name: &#39;perpendicularoffset&#39;,
                minValue: -500,
                maxValue: 500,
                listeners: listenerConfig
            }, {
                xtype: &#39;checkbox&#39;,
                bind: {
                    fieldLabel: &#39;{textFollowLineLabel}&#39;
                },
                name: &#39;followlinelabel&#39;,
                value: followLineLabel,
                listeners: listenerConfig
            });
        } else {
            fs.items.push({
                xtype: &#39;numberfield&#39;,
                bind: {
                    fieldLabel: &#39;{textAnchorPointXLabel}&#39;
                },
                value: labelAnchorPointX,
                name: &#39;labelanchorpointx&#39;,
                type: &#39;float&#39;,
                allowDecimals: true,
                decimalPrecision: 1,
                decimalSeparator: &#39;.&#39;,
                step: 0.1,
                minValue: -500,
                maxValue: 500,
                listeners: listenerConfig
            }, {
                xtype: &#39;numberfield&#39;,
                bind: {
                    fieldLabel: &#39;{textAnchorPointYLabel}&#39;
                },
                value: labelAnchorPointY,
                name: &#39;labelanchorpointy&#39;,
                allowDecimals: true,
                decimalPrecision: 1,
                decimalSeparator: &#39;.&#39;,
                step: 0.1,
                minValue: -500,
                maxValue: 500,
                listeners: listenerConfig
            }, {
                xtype: &#39;numberfield&#39;,
                bind: {
                    fieldLabel: &#39;{textDisplacementXLabel}&#39;
                },
                value: labelDisplacementX,
                name: &#39;labeldisplacementx&#39;,
                minValue: -500,
                maxValue: 500,
                listeners: listenerConfig
            }, {
                xtype: &#39;numberfield&#39;,
                bind: {
                    fieldLabel: &#39;{textDisplacementYLabel}&#39;
                },
                value: labelDisplacementY,
                name: &#39;labeldisplacementy&#39;,
                minValue: -500,
                maxValue: 500,
                listeners: listenerConfig
            }, {
                xtype: &#39;numberfield&#39;,
                bind: {
                    fieldLabel: &#39;{textRotationLabel}&#39;
                },
                value: labelRotation,
                name: &#39;labelrotation&#39;,
                minValue: 0,
                maxValue: 359,
                listeners: listenerConfig
            });
        }
        return fs;
    },

<span id='BasiGX-view-container-SLDStyler-method-createSLDPreviewMap'>    /**
</span>     * Creates an ol map to preview the current SLD
     *
     * @return {Object} An ExtJS configuration object for the map panel
     */
    createSLDPreviewMap: function() {
        var layer = new ol.layer.Tile({
            source: new ol.source.TileWMS({
                url: this.getBackendUrls().geoServerUrl,
                params: {
                    &#39;LAYERS&#39;: this.getLayer(),
                    &#39;TILED&#39;: true
                },
                tileLoadFunction: function(image, url) {
                    var img = image.getImage();
                    if (typeof Blob === &#39;function&#39;) {
                        var baseUrl = url.split(&#39;?&#39;)[0];
                        var params = url.split(&#39;?&#39;)[1];
                        params = params.split(&#39;&amp;&#39;);
                        var paramObj = {};
                        Ext.each(params, function(param) {
                            var split = param.split(&#39;=&#39;);
                            var key = decodeURIComponent(split[0]);
                            var value = decodeURIComponent(split[1]);
                            paramObj[key] = value;
                        });
                        Ext.Ajax.request({
                            binary: true,
                            url: baseUrl,
                            method: &#39;POST&#39;,
                            params: paramObj,
                            defaultHeaders: BasiGX.util.CSRF.getHeader(),
                            scope: this,
                            success: function(response) {
                                if (response.responseBytes) {
                                    var blob = new Blob(
                                        [response.responseBytes],
                                        {type: &#39;image/png&#39;}
                                    );
                                    var blobUrl = window.URL.createObjectURL(
                                        blob);
                                    img.src = blobUrl;
                                }
                            }
                        });
                    } else {
                        img.src = url;
                    }
                }
            })
        });
        var panel = {
            xtype: &#39;gx_component_map&#39;,
            layers: [layer],
            map: new ol.Map({
                layers: [layer],
                controls: [new ol.control.Zoom()],
                view: new ol.View({
                    center: [0,0],
                    zoom: 1
                })
            }),
            name: &#39;sldpreview-&#39; + this.getMode(),
            width: &#39;100%&#39;,
            minHeight: 310
        };
        return panel;
    },

<span id='BasiGX-view-container-SLDStyler-method-getSingleFeatureForPreview'>    getSingleFeatureForPreview: function() {
</span>        var me = this;
        var geoServerUrl = me.getBackendUrls().geoServerUrl;
        Ext.Ajax.request({
            url: geoServerUrl,
            method: &#39;GET&#39;,
            params: {
                service: &#39;WFS&#39;,
                request: &#39;GetFeature&#39;,
                typeName: me.getLayer(),
                version: &#39;1.0.0&#39;,
                maxFeatures: 1,
                outputFormat: &#39;application/json&#39;
            },
            defaultHeaders: BasiGX.util.CSRF.getHeader(),
            scope: this,
            success: function(response) {
                try {
                    var json = Ext.decode(response.responseText);
                    if (json.features &amp;&amp; json.features.length &gt; 0 &amp;&amp;
                        json.crs &amp;&amp; json.crs.properties &amp;&amp;
                        json.crs.properties.name) {
                        var feature = json.features[0];
                        var reader = new ol.format.GeoJSON();
                        var olFeature = reader.readFeature(feature);
                        // make the attributes available for label configuration
                        me.attributeStore.removeAll();
                        Ext.iterate(feature.properties, function(k, v) {
                            me.attributeStore.add(
                                {&#39;name&#39;: k, &#39;value&#39;: v}
                            );
                        });
                        // then get the extent for map extent adjustments
                        var extent = olFeature.getGeometry().getExtent();
                        var srsCode = json.crs.properties.name.split(
                            &#39;EPSG::&#39;)[1];
                        var srs = &#39;EPSG:&#39; + srsCode;
                        if (extent &amp;&amp; srsCode) {
                            me.getPreviewForSingleFeature(extent, srs);
                        } else {
                            Ext.log.error(&#39;Could not retrieve a feature &#39; +
                                &#39;via WFS for preview&#39;);
                        }
                    }
                } catch (e) {
                    Ext.log.error(&#39;Could not retrieve a feature &#39; +
                        &#39;via WFS for preview&#39;);
                }
            },
            failure: function() {
                Ext.log.error(&#39;Could not retrieve a feature &#39; +
                    &#39;via WFS for preview&#39;);
            }
        });
    },

<span id='BasiGX-view-container-SLDStyler-method-getPreviewForSingleFeature'>    getPreviewForSingleFeature: function(extent, srs) {
</span>        var selector = &#39;gx_component_map[name=sldpreview-&#39; +
            this.getMode() + &#39;]&#39;;
        var mapPanel = Ext.ComponentQuery.query(selector)[0];
        var map = mapPanel.map;
        var view = new ol.View({
            projection: srs
        });
        view.fit(extent);
        map.setView(view);
    },

<span id='BasiGX-view-container-SLDStyler-method-updateSLDPreview'>    /**
</span>     * Method updates the SLD Preview with the current state of the form values
     */
    updateSLDPreview: function() {
        var me = this;
        var selector = &#39;gx_component_map[name=sldpreview-&#39; + me.getMode() + &#39;]&#39;;
        var mapPanel = Ext.ComponentQuery.query(selector)[0];
        if (mapPanel) {
            var map = mapPanel.map;
            var layer = map.getLayers().getArray()[0];
            if (layer) {
                var sld = me.getSldFromFormValues();
                var ruleName = me.getRuleName();
                layer.getSource().updateParams({
                    RULE: ruleName,
                    SLD_BODY: sld
                });
            }
            // try to get a single feature via WFS to render
            // a map with it in order to be able to preview &quot;real&quot; data
            // and also to show labels / textsymbolizers.
            if (!me.mapCentered) {
                me.getSingleFeatureForPreview();
                me.mapCentered = true;
            }
        }
    },

<span id='BasiGX-view-container-SLDStyler-method-getSldFromFormValues'>    /**
</span>     * Method transforms the current form values into a valid SLD string,
     * which is then used to preview the current style with the help of an
     * `GetLegendGraphic` request issued against the GeoServer
     *
     * @return {String} sld The SLD string representing the current state of
     *     the form values
     */
    getSldFromFormValues: function() {
        var me = this;
        var selector = &#39;fieldset[name=&#39; + this.getMode() + &#39;style]&#39;;
        var fs = Ext.ComponentQuery.query(selector)[0];
        var sldObj = this.getSldObj();
        var value;
        if (!fs || !sldObj) {
            return &#39;&#39;;
        }

        var radiusFs = fs.down(&#39;[name=radius]&#39;);
        var graphicTab = fs.down(&#39;[name=graphic]&#39;);
        var graphicTabActive = false;
        var textFs = fs.up(&#39;basigx-container-sldstyler&#39;).down(
            &#39;fieldset[name=textsymbolizer]&#39;);

        if (graphicTab) {
            var activeTab = graphicTab.up(&#39;tabpanel&#39;).getActiveTab();
            if (activeTab === graphicTab) {
                graphicTabActive = true;
            }
        }

        var fillFs = graphicTabActive ? graphicTab.down(&#39;[name=fill]&#39;) :
            fs.down(&#39;[name=fill]&#39;);
        var strokeFs = graphicTabActive ? graphicTab.down(&#39;[name=stroke]&#39;) :
            fs.down(&#39;[name=stroke]&#39;);
        var strokeWidthFs = graphicTabActive ?
            graphicTab.down(&#39;[name=stroke-width]&#39;) :
            fs.down(&#39;[name=stroke-width]&#39;);

        var symbolizerObj = {};

        if (fillFs) {
            symbolizerObj.fillColor = &#39;#&#39; + fillFs.getValue().substring(0, 6);
            symbolizerObj.fillOpacity = BasiGX.util.Color.rgbaAsArray(
                BasiGX.util.Color.hex8ToRgba(fillFs.getValue()))[4];
        }

        if (strokeFs) {
            symbolizerObj.strokeColor = &#39;#&#39; + strokeFs.getValue()
                .substring(0, 6);
            symbolizerObj.strokeOpacity = BasiGX.util.Color.rgbaAsArray(
                BasiGX.util.Color.hex8ToRgba(strokeFs.getValue()))[4];
        }

        if (strokeWidthFs) {
            value = strokeWidthFs.getValue();
            if (Ext.isNumber(value)) {
                symbolizerObj.strokeWidth = value.toString();
            } else {
                symbolizerObj.strokeWidth =
                    BasiGX.util.SLD.DEFAULT_STROKE_WIDTH.toString();
            }
        }

        if (!graphicTabActive &amp;&amp; radiusFs) {
            value = radiusFs.getValue();
            if (Ext.isNumber(value)) {
                symbolizerObj.radius = value.toString();
            } else {
                symbolizerObj.radius =
                    BasiGX.util.SLD.DEFAULT_POINT_RADIUS.toString();
            }
        }

        if (graphicTabActive) {
            // only write external graphic or font values when the graphic
            // tab is active
            var scale = graphicTab.down(&#39;[name=graphic-scale]&#39;).getValue();
            var opacity = graphicTab.down(&#39;[name=graphic-opacity]&#39;)
                .getValue() / 100;
            var rotation = graphicTab.down(&#39;[name=graphic-rotation]&#39;)
                .getValue();
            if (graphicTab.externalGraphicSrc) {
                var src = graphicTab.externalGraphicSrc;
                var internalUrl = this.config.backendUrls.internalUrl;
                var regex = /https?:\/\/[a-zA-Z\-_0-9.]+\//g;
                if (this.config.backendUrls.internalUrl) {
                    src = src.replace(regex, internalUrl);
                }
                symbolizerObj.externalGraphicSrc = src;
            }
            if (graphicTab.fontAndUniCode) {
                symbolizerObj.fontAndUniCode = graphicTab.fontAndUniCode;
            }
            symbolizerObj.graphicSize = scale ? scale.toString() :
                BasiGX.util.SLD.DEFAULT_GRAPHIC_SIZE.toString();
            symbolizerObj.graphicOpacity = opacity ? opacity.toString() :
                BasiGX.util.SLD.DEFAULT_GRAPHIC_OPACITY.toString();
            symbolizerObj.graphicRotation = rotation ? rotation.toString() :
                BasiGX.util.SLD.DEFAULT_GRAPHIC_ROTATION.toString();
        }

        if (this.getMode() === &#39;point&#39;) {
            sldObj = BasiGX.util.SLD.setPointSymbolizerInRule(
                symbolizerObj,
                me.getRuleName(),
                sldObj
            );
        } else if (this.getMode() === &#39;line&#39;) {
            sldObj = BasiGX.util.SLD.setLineSymbolizerInRule(
                symbolizerObj,
                me.getRuleName(),
                sldObj
            );
        } else if (this.getMode() === &#39;polygon&#39;) {
            sldObj = BasiGX.util.SLD.setPolygonSymbolizerInRule(
                symbolizerObj,
                me.getRuleName(),
                sldObj
            );
        }

        if (textFs) {
            if (textFs.checkboxCmp.checked) {
                // Set text symbolizer only if the checkbox &quot;text style&quot;
                // is checked
                symbolizerObj.labelAttribute = textFs.down(
                    &#39;combo[name=labelattribute]&#39;).getValue() ||
                    BasiGX.util.SLD.DEFAULT_LABEL_ATTRIBUTE;
                symbolizerObj.fontSize = textFs.down(
                    &#39;numberfield[name=fontsize]&#39;).getValue().toString() ||
                    BasiGX.util.SLD.DEFAULT_FONTSIZE;
                symbolizerObj.fontFamily = textFs.down(
                    &#39;combo[name=fontfamily]&#39;).getValue() ||
                    BasiGX.util.SLD.DEFAULT_FONT_FAMILY;
                symbolizerObj.fontWeight = textFs.down(
                    &#39;combo[name=fontweight]&#39;).getValue() ||
                    BasiGX.util.SLD.DEFAULT_FONT_WEIGHT;
                symbolizerObj.fontStyle = textFs.down(
                    &#39;combo[name=fontstyle]&#39;).getValue() ||
                    BasiGX.util.SLD.DEFAULT_FONT_STYLE;
                symbolizerObj.fontFillColor = BasiGX.util.SLD.
                    DEFAULT_FONT_FILLCOLOR;
                symbolizerObj.fontFillOpacity = 0;

                var textFillFs = textFs.down(&#39;colorbutton[name=fill]&#39;);
                if (textFillFs) {
                    symbolizerObj.fontFillColor = &#39;#&#39; + textFillFs.getValue()
                        .substring(0, 6);
                    symbolizerObj.fontFillOpacity = BasiGX.util.Color
                        .rgbaAsArray(BasiGX.util.Color.hex8ToRgba(textFillFs
                            .getValue()))[4];
                }

                if (this.getMode() === &#39;line&#39;) {
                    symbolizerObj.perpendicularOffset = textFs.down(
                        &#39;numberfield[name=perpendicularoffset]&#39;)
                        .getValue().toString() || BasiGX.util.SLD.
                        DEFAULT_LABEL_PERPENDICULAROFFSET;
                    symbolizerObj.labelFollowLine = textFs.down(
                        &#39;checkbox[name=followlinelabel]&#39;)
                        .getValue().toString() || BasiGX.util.SLD.
                        DEFAULT_LABEL_FOLLOW_LINE;
                } else {
                    symbolizerObj.labelAnchorPointX = textFs.down(
                        &#39;numberfield[name=labelanchorpointx]&#39;)
                        .getValue().toString() || BasiGX.util.SLD.
                        DEFAULT_LABEL_ANCHORPOINTX;
                    symbolizerObj.labelAnchorPointY = textFs.down(
                        &#39;numberfield[name=labelanchorpointy]&#39;)
                        .getValue().toString() || BasiGX.util.SLD.
                        DEFAULT_LABEL_ANCHORPOINTY;
                    symbolizerObj.labelDisplacementX = textFs.down(
                        &#39;numberfield[name=labeldisplacementx]&#39;)
                        .getValue().toString() || BasiGX.util.SLD.
                        DEFAULT_LABEL_DISPLACEMENTX;
                    symbolizerObj.labelDisplacementY = textFs.down(
                        &#39;numberfield[name=labeldisplacementy]&#39;)
                        .getValue().toString() || BasiGX.util.SLD.
                        DEFAULT_LABEL_DISPLACEMENTY;
                    symbolizerObj.labelRotation = textFs.down(
                        &#39;numberfield[name=labelrotation]&#39;)
                        .getValue().toString() || BasiGX.util.SLD.
                        DEFAULT_LABEL_ROTATION;
                }

                sldObj = BasiGX.util.SLD.setTextSymbolizerInRule(
                    symbolizerObj,
                    me.getRuleName(),
                    sldObj
                );
            } else {
                // If the checkbox &quot;text style&quot; is unchecked, remove the text
                // symbolizer from sldObj
                sldObj = BasiGX.util.SLD.removeTextSymbolizerFromRule(
                    me.getRuleName(), sldObj);
            }
        }

        var sld = BasiGX.util.SLD.toSldString(sldObj);

        // update our properties
        me.setSld(sld);
        me.setRule(BasiGX.util.SLD.getRuleByName(me.getRuleName(), sldObj));
        me.setSldObj(sldObj);

        return sld;

    },

<span id='BasiGX-view-container-SLDStyler-method-onChooseFontClick'>    /**
</span>     * Creates and shows a window with a `BasiGX.view.panel.FontSymbolPool`,
     * that allows the user to pick a font and symbol for setting a ttf mark
     * in the sld
     */
    onChooseFontClick: function() {
        var me = this;
        var callbackFn = function(fullQualifiedGlyphName) {
            var graphicFs = me.down(&#39;[name=graphic]&#39;);
            graphicFs.fontAndUniCode = fullQualifiedGlyphName;
            // unset an potential external graphic
            graphicFs.externalGraphicSrc = null;
            // set matching style options
            if (me.getMode() === &#39;point&#39;) {
                graphicFs.down(&#39;[name=graphic-opacity]&#39;).setDisabled(true);
            }
            if (me.getMode() === &#39;polygon&#39;) {
                graphicFs.down(&#39;[name=graphic-rotation]&#39;).setDisabled(false);
            }
            graphicFs.down(&#39;[name=fill]&#39;).setDisabled(false);
            graphicFs.down(&#39;[name=stroke]&#39;).setDisabled(false);
            graphicFs.down(&#39;[name=stroke-width]&#39;).setDisabled(false);
            graphicFs.down(&#39;[name=stroke-width]&#39;).setValue(1);
            me.updateSLDPreview();
        };

        // cleanup
        var selector = &#39;window[title=&#39; +
            me.getViewModel().get(&#39;fontSymbolPoolWindowTitle&#39;) + &#39;]&#39;;
        var wins = Ext.ComponentQuery.query(selector);
        Ext.each(wins, function(win) {
            win.destroy();
        });

        var fontSymbolPool = Ext.create(&#39;BasiGX.view.panel.FontSymbolPool&#39;, {
            geoserverFontListUrl: me.getBackendUrls().geoserverFontListUrl,
            geoserverFontUrl: me.getBackendUrls().geoserverFontUrl,
            useCsrfToken: true,
            onGlyphSelected: callbackFn
        });

        var fontSymbolPoolWin = Ext.create(&#39;Ext.window.Window&#39;, {
            title: me.getViewModel().get(&#39;fontSymbolPoolWindowTitle&#39;),
            constrain: true,
            items: [fontSymbolPool]
        });
        fontSymbolPoolWin.showAt(5, 5);
    },

<span id='BasiGX-view-container-SLDStyler-method-onChooseGraphicClick'>    /**
</span>     * Creates and shows a window with a `BasiGX.view.panel.GraphicPool`, that
     * will eventually update both the preview and also the styles in the
     * attached layer.
     */
    onChooseGraphicClick: function() {
        var me = this;
        var okClickCallbackFn = function(pictureRec) {
            var pictureUrl = BasiGX.util.Url.getWebProjectBaseUrl() +
                me.getBackendUrls().pictureSrc.url +
                pictureRec.get(&#39;id&#39;);
            var graphicFs = me.down(&#39;[name=graphic]&#39;);
            graphicFs.externalGraphicSrc = pictureUrl;
            // unset an potential font and glyph
            graphicFs.fontAndUniCode = null;
            // set matching style options
            if (me.getMode() === &#39;point&#39;) {
                graphicFs.down(&#39;[name=graphic-opacity]&#39;).setDisabled(false);
            }
            if (me.getMode() === &#39;polygon&#39;) {
                graphicFs.down(&#39;[name=graphic-rotation]&#39;).setDisabled(true);
            }
            graphicFs.down(&#39;[name=fill]&#39;).setDisabled(true);
            graphicFs.down(&#39;[name=stroke]&#39;).setDisabled(true);
            graphicFs.down(&#39;[name=stroke-width]&#39;).setDisabled(true);
            me.updateSLDPreview();
        };

        var deleteClickCallbackFn = function() {
            Ext.toast(
                me.getViewModel().get(&#39;pointGrapicDeletedSuccessMsgText&#39;),
                me.getViewModel().get(&#39;pointGrapicDeletedSuccessMsgTitle&#39;),
                &#39;t&#39;
            );
        };

        var graphicPool = Ext.create(&#39;BasiGX.view.panel.GraphicPool&#39;, {
            backendUrls: me.getBackendUrls(),
            okClickCallbackFn: okClickCallbackFn,
            deleteClickCallbackFn: deleteClickCallbackFn,
            useCsrfToken: true
        });

        var graphicPoolWin = Ext.create(&#39;Ext.window.Window&#39;, {
            title: me.getViewModel().get(&#39;graphicPoolWindowTitle&#39;),
            constrain: true,
            items: [graphicPool]
        });
        graphicPoolWin.show();
    }
});
</pre>
</body>
</html>
